<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于医院]]></title>
    <url>%2F2017%2F09%2F04%2F%E5%85%B3%E4%BA%8E%E5%8C%BB%E9%99%A2%2F</url>
    <content type="text"><![CDATA[网上看到的段子，看完后觉得有共鸣 医院院长电动车坏了，拿到一个大修理店去修。修理店接待人员: “OK，开机费50元”医院院长: “为什么还没修理就要先交费”？修理店接待人员: “我们修理店的制度就是这样，你们医院的挂号费，不是没看病之前就要交吗”？医院院长无话可说，只好交了50元。修理店接待人员问：“你好，请问你的电动车出了什么问题？”医院院长:“就是没有反应了，工程师先开了三个付费单请医院院长交费：一、万用表测量费20元；二、控制器检测费50元；三、电机检测费80元。医院院长惊问：“为什么要顾客出这个测试费，这不是方便你们修理工程师的吗？”工程师：“没错，我们的工程师以前也是靠“望、闻、问、切、听”，凭经验修理，可是现在科学发达了什么仪器都有了，修理时做了测试会比较准确，也可能修不好你的电动车，最后耽误你的时间。”医院院长只好先交了150元测试费。工程师经过半个小时测试，用打印机打出一张线路图，发现是一个保险丝烧了，他花几分钟，换了个二元钱的保险丝就修好了电动车。工程师把打印好的线路图塞到院长手中后开了一张缴费单，叫医院院长去交8元打印费。院长不解的问：“打印费也要我出啊？”“是的，这是店里的规定，打印费由顾客出，那张图不是给你了吗？”“可我看不懂啊，要这张图干啥？”“你们医院给病人做B超，打印的绘图病人也看不懂啊，不照样是病人出钱吗”？最后，工程师对院长说，我们店实行电脑管理，请你去提货柜台提货。提货柜台打了一个修理清单给医院院长交费，缴费单上写着：“据物价局规定，我店实行分项收费，做到使顾客明明白白消费，你本次修理收费如下：35W白光牌烙铁使用费（拆焊各1次）：20元；一次性烙铁头清洁棉：1 2元；吸枪使用费1次：15元；φ0.8环保锡线10g :15元；2N1234保险管1个：12元；剪保险丝管脚斜口钳使用费：15元；焊接后清洗焊盘洗板水费：15元；拆焊保险管、清洗焊盘等人工费： 30元；其它……920元合计：1054元”。医院院长看了差点晕倒，医院院长修电动车共花了1282元钱，只换了一个价值二元的配件。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在七夕前夕]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%86%99%E5%9C%A8%E4%B8%83%E5%A4%95%E5%89%8D%E5%A4%95%2F</url>
    <content type="text"><![CDATA[2017，超速的一年，虽然仅仅过去了一半有余 千头万绪，不知从何说起，就像一直以来的处境，茫目焦虑。流水账的给自己梳理记录下。 感情年前初识的甜蜜浓浓，春节期间的相思义无反顾，年后的热恋疯狂。就像小说，冲动的年纪，必然有冥冥中的结果。两个人生活的结合、即将演变成的三人世界，虽猝不及防，却也不失是一种别样的成长与责任。 那个轻浮的毛头小子，你够努力了么 家庭像吃经验书升级般的感情经历。带来最直接的变化莫过于对家庭的影响。这些日子，丈母娘在身边照顾老婆，老丈人也因为身体抱恙被小舅子陪着来到北京看病。 北京的租住处，竟然莫名有了浓浓的家味。茶前饭后，看着老婆一家逗逗乐拌拌嘴，就总在想千里之外的老头老娘。你工作忙，所以我都不敢但电话给你，就怕打扰你。,恩，你有空就给我打电话，我在家又没什么事。主要就是看你们可由什么需要。想想以前单身狗时，工作结束、游戏期间，还会想着给老头老年敲个电话吧，现在竟惊恐的发现一天，可以毫无察觉的度过，没有社交、没有家人的嘘寒问暖。深深的内疚。 那个老头老娘挂念的儿子，你要继续学习感恩 工作人的精力有限。17年上半年的林林总总，机关枪般的扫射下，精力从一个个单孔里飞速流逝。不得不承认，在工作上，以往同事眼中敬职敬责的木豆，已经开始变味了。 这是个很不乐观的局面。鑫哥有句话很入我心：工作也好，做人也罢。口碑这个东西，特别重要。而且好口碑难塑，破坏起来，太容易了。我明白我现在的处境实际上已经快要把口碑改造成墓碑了。 那个兢兢业业的木豆，我姑且保留对你的口碑，不要让大家失望 学习这半年来，工作上的负面影响，也带入到了平时的学习充电中。这块没有任何借口，计划好的书本，啃了多少。想学的知识，实际开始学习了的又有多少。 同时，工作领域的危机感，也越来越强。鑫哥已经用他的实际行动告诉我们，必须保持高速学习、必须明确区分主次。 学习、提升，没有捷径。如果有，那唯一的方法就是迎风向前 最后主题七夕，结束了二十多年的单身狗的生活。第一个七夕情人节。努力能给我爱的人，幸福的一生。 PS.最近发现，书必须得读。不能再拖延了发现个很好的个人博客：小土刀，羡慕博主的各种方法论、世界观。希望能借鉴并提升自己。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[黑马程序-银行客户调度系统]]></title>
    <url>%2F2014%2F01%2F13%2F%E9%93%B6%E8%A1%8C%E5%AE%A2%E6%88%B7%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[事物抽象化分析:项目需求: 用代码演示一个建议的银行业务调度系统,(其实就是叫号系统.)思路分析:从名词下手,分析可能需要定义的类:客户:普通客户,快速客户,VIP客户.窗口:普通窗口,快速窗口,VIP窗口.用户编号:普通编号,快速编号,VIP编号(一个编号对应一个客户)再从行为上下手,具体分析:客户和编号关联,所以用产生一个编号,对应一个客户.——&gt;编号产生类.客户类型不同,所以需要上述不同的三个编号产生类.同时要对他们进行调度—–&gt;编号管理类.服务窗口,对应不同的服务类型,存在三种窗口类型,但每种类型有不同.所以将窗口抽取,类型定义枚举.——&gt;窗口类型枚举,窗口类.下面是跟着老师的步骤一步步来的代码.状态不好,勉强跟上老师思路.还是有很多模糊的地方.想放代码.慢慢消化 服务编号产生类 //定义某个服务编号产生类. public class Code{ //定义某服务类型下一个号. private int nextCode = 0; private List &lt;Integer> listsCode = new LinkedList&lt;Integer>(); //定义取号方法.返回及其中的下一个号. public synchronized Integer createNewCode(){ listCode.addLast(++nextCode); return nextCode; } //定义分配号方法 public synchronized Integer fetchCode(){ if(listsCode.size()>0){ return(listsCode.removeFist()); }else{ return null; } } } 编号操作类 //定义编号操作机,对应不同服务类型产生同一个的操作机,否则无法同步.(操作包括取号,分配号) public class CodeMachine{ //设置单例.毕竟应该只有一个 private CodeMachine(){} private static CodeMachine single = new CodeMachine(); public static CodeMachine getInstance(){ return single; } //定义不同服务类型编号的成员属性.代表该机器中可操作的编号类型那个.并定义获取方法. private Code commonCode = new Code(); private Code expressCode = new Code(); private Code vipCode = new Code(); public Code getCommonCode() { return commonCode; } public Code getExpressCode() { return expressCode; } public Code getVipCode() { return vipCode; } } 服务类型的枚举 //定义枚举类服务类型 public enum CustomerType { //为了让窗口类只有一个,不同窗口实例对象是通过从枚举中获得某一特定服务类型. COMMON,EXPRESS,VIP; public String toString(){ String name = null; //这里,switch可以用String是从JDK5以后来的新特性.正好方便编程. switch(this){ case COMMON: name = "普通"; break; case EXPRESS: name = "快速"; break; case VIP: name = name(); break; } return name; } } 服务窗口类 //定义服务窗口类 public class ServiceWindow{ //从定义了的枚举类中,获取服务类型. private CustomerType type = CustomerType.COMMON; //定义窗口编号.及其设置方法 private int number = 1; public void setNumber(int number){ this.number = number; } //定义设置,获取服务类型的方法 public CustomerType getType() { return type; } public void setType(CustomerType type) { this.type = type; } //用单线程池来让某个服务类型的窗口,调用该类型服务的方法. public void start(){ Executors.newSingleThreadExecutor().execute( new Runnable(){ public void run(){ switch(type){ while(true){ //调用对应类型的服务方法. case COMMON: commonService(); break; case EXPRESS: expressService(); break; case VIP: vipService(); break; } } } } ); } //定义不同类型服务方法. //定义普通服务 private void commonService(){ String windowName = "第" + number + "号" + type + "窗口"; System.out.println(windowName + "开始等待普通服务客户"); Integer serviceNumber = CodeMachine.getInstance().getCommonCode().fetchCode(); if(serviceNumber != null ){ System.out.println(windowName + "开始为" + serviceNumber + "号普通客户服务"); int maxRandom = Constants.MAX_SERVICE_TIME - Constants.MIN_SERVICE_TIME; int serviceTime = new Random().nextInt(maxRandom)+1 + Constants.MIN_SERVICE_TIME; try { Thread.sleep(serviceTime); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(windowName + "完成为" + serviceNumber + "号普通客户服务，耗时" + serviceTime/1000 + "秒"); }else{ System.out.println(windowName + "无普通服务等待客户，休整一秒"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } //定义快速服务 private void expressService(){ Integer serviceNumber = CodeMachine.getInstance().getExpressCode().fetchCode(); String windowName = "第" + number + "号" + type + "窗口"; System.out.println(windowName + "开始等待快速服务客户"); if(serviceNumber !=null){ System.out.println(windowName + "开始为" + serviceNumber + "号快速客户服务"); int serviceTime = Constants.MIN_SERVICE_TIME; try { Thread.sleep(serviceTime); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(windowName + "完成" + serviceNumber + "号快速客户服务，耗时" + serviceTime/1000 + "秒"); }else{ System.out.println(windowName + "无快速服务等待客户"); commonService(); } } //定义VIP服务 private void vipService(){ Integer serviceNumber = CodeMachine.getInstance().getVipCode().fetchCode(); String windowName = "第" + number + "号" + type + "窗口"; System.out.println(windowName + "开始等待VIP服务客户"); if(serviceNumber !=null){ System.out.println(windowName + "开始为" + serviceNumber + "号VIP客户服务"); int maxRandom = Constants.MAX_SERVICE_TIME - Constants.MIN_SERVICE_TIME; int serviceTime = new Random().nextInt(maxRandom)+1 + Constants.MIN_SERVICE_TIME; try { Thread.sleep(serviceTime); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(windowName + "完成" + serviceNumber + "号VIP客户服务，耗时" + serviceTime/1000 + "秒"); }else{ System.out.println(windowName + "无VIP服务等待客户"); commonService(); } } } 测试类 //定义测试类,生成一定数目窗口,一定数目顾客,执行服务. public class MainClass { public static void main(String[] args) { //开放普通窗口并进行实例化 for(int i=1;i&lt;5;i++){ ServiceWindow window = new ServiceWindow(); window.setNumber(i); window.start(); } //开放快速窗口 //窗口实例化时,通过调用setType()方法确定了服务类型 ServiceWindow expressWindow = new ServiceWindow(); expressWindow.setType(CustomerType.EXPRESS); expressWindow.start(); //开放VIP窗口 ServiceWindow vipWindow = new ServiceWindow(); vipWindow.setType(CustomerType.VIP); vipWindow.start(); //普通客户拿号 Executors.newScheduledThreadPool(1).scheduleAtFixedRate( new Runnable(){ public void run(){ Integer serviceNumber = CodeMachine.getInstance().getCommonCode().createNewCode(); System.out.println(serviceNumber + "号普通客户\t等待服务"); } }, 0, new Random().nextInt(10)+1, TimeUnit.SECONDS); //快速客户拿号 Executors.newScheduledThreadPool(1).scheduleAtFixedRate( new Runnable(){ public void run(){ Integer serviceNumber = CodeMachine.getInstance().getExpressCode().createNewCdoe(); System.out.println(serviceNumber + "号快速客户\t等待服务"); } }, 0, (new Random().nextInt(10)+1)*2, TimeUnit.SECONDS); //VIP客户拿号 Executors.newScheduledThreadPool(1).scheduleAtFixedRate( new Runnable(){ public void run(){ Integer serviceNumber = CodeMachine.getInstance().getVipCode().createNewCode(); System.out.println(serviceNumber + "号VIP客户\t等待服务"); } }, 0, (new Random().nextInt(10)+1)*6, TimeUnit.SECONDS); } } 问题:其实一直有个不知道怎么实现的想法,我认为服务窗口的服务类型,是体现在客户类型上.应该是由客户的需啊服务类型,决定窗口的最终服务类型. 是不是可以把窗口真实提供的服务,和通常应该提供的服务作为类型抽取出来,想父类引用指向子类对象那样,可以向下兼容的提供服务.哎,算了,思维比较混了,表达的可能也是比较混乱. 等捋顺了,再更新.]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
        <tag>黑马程序员</tag>
        <tag>基础视频</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-交通灯管理系统]]></title>
    <url>%2F2014%2F01%2F12%2F%E4%BA%A4%E9%80%9A%E7%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[我的初期代码啥也不说了,线上代码.很经典的题目… 我觉得在定义Road中存储汽车的集合,应该用LinkedList,因为有addFist和removeLast方法,既符合实际情况,有相对于没有查询,只增删操作,也提高了效率.还有在定义枚举红绿灯时,也有点小想法,但是还不成熟,先按照老师的整体思路,一步步按照自己的想法做了一遍. /* 需求: 模拟十字路口交通灯管理系统 分析: 代码体现现实生活,则需要分析哪些对象,分析用什么类型数据进行代码化. 这里这样分析: 名词提炼:有路,有车,有灯 再提炼动作:车来,车过红绿灯,灯变化. 所以总结: 用集合抽象道路,枚举抽象红绿灯,一个操作类抽象灯控制器,一个描述类抽象汽车. 步骤: 1.定义路类集合.用来存储要过红绿灯的汽车.&lt;四&gt; 2.定义灯枚举类,每个实例对象存在四大方向,每个方向有左转,右转,直行3个子属性,并且关联有对应转换方法.&lt;十二&gt; 3.定义汽车描述类,具有来需要行进方向属,性即:要左行,要右行,要中行.&lt;一&gt; 4.定义交通灯的控制类.初始化交通灯. 5.定义测试类. */ //定义汽车类. public class Car{ //定义行进方向数组. static String[] towardsArr = {&quot;左转&quot;,&quot;直行&quot;,&quot;右转&quot;}; privateString towards; public getTowards(){ return towards; } //定义无参构造,车产生则明确行进方向. public Car(){ this.towards = towardsArr[new Random().next(3)]; } } //定义道路类. public class Rode{ private List&lt;Car&gt; cars = new LinkedList&lt;Car&gt;(); private String name; public Road(String name){ this.name = name; //1到5秒随机产生一辆需要过红绿灯的车. ExecutorService pool = Executors.newSingleThreadExecutor(); pool.execute(new Runnable(){ public void run(){ while(true){ try { Thread.sleep((new Random().nextInt(10)+1)*1000); }catch (InterruptedException e) { e.printStackTrace(); } //出现一辆需要过红绿灯的车 Car temp = new Car(); cars.addLast(temp); } } }); //定义一个定时器,每个1秒检查红绿灯状态,匹配该路上第一辆车行进方向为绿灯,则该车通行. ScheduledExecutorService timer = Executors.newScheduledThreadPool(1); timer.scheduleAtFixedRate(new Runnable(){ public void run(){ //判断该路上是否有车,没有车则无需通行. if(cars.size()&gt;0){ //判断该车所要去方向是否为绿灯,是则通行. boolean lighted = Lamp.valueOf(Road.this.name+temp.getTowards).isLighted(); if(lighted){ System.out.println(&quot;来自&quot;+Road.this.name+temp.towards+&quot;车辆行驶通过..oO&quot;); } } } },1,1,TimeUnit.SECONDS); } } //定义红路灯的枚举 public enum Lamp{ //四个红绿灯.分别以来自某条路和行进方向来命名. 东右转(null,null,true),东左转(&quot;西左转&quot;,&quot;南直行&quot;,false),东直行(&quot;西直行&quot;,&quot;东左转&quot;,false), 西右转(null,null,true),西左转(null,null,false),西直行(null,null,false), 南右转(null,null,true),南左转(&quot;北左转&quot;,&quot;东直行&quot;,false),南直行(&quot;北直行&quot;,&quot;南左转&quot;,false), 北右转(null,null,true),北左转(null,null,false),北直行(null,null,false); //成员属性:是否绿灯(默认为关闭) private boolean lighted; //定义获取等状态的方法方法 public boolean isLighted(){ return lighted; } //每个灯对应有相对的灯,和左转灯的指向.(这里因为是枚举,就用那个灯名的字符串代替了) private String opposite; private String next; //用构造定义逆向方向看到的灯和左转方向看到的灯的关联关系. //这里要明确,红绿灯方式为:直行,左转,再逆向直行,逆向左转.右转忽略. private Lamp(String opposite, String next, boolean lighted){ this.opposite = opposite; this.next = next; this.lighted = lighted; } //当直行方向绿灯亮起的时候,逆向的绿灯也亮起 public void light(){ this.lighted = true; //判断该灯是否为直行灯(即他有没有逆向灯.)有则同变绿. if(opposite != null){ Lamp.valueOf(opposite).lights(); } } //当一个灯变红时,他对面的灯变红,同时他的 public Lamp turnOff(){ this.lighted = false; if(opposite != null){ Lamp.valueOf(opposite).turnOff(); } //一个方向的直行左转结束后,就要到逆向的 Lamp Lamp = null; if (next != null) { nextLamp = Lamp.valueOf(next); nextLamp.light(); } return nextLamp; } } //定义红绿灯控制器 public class LampCotroller { //控制器的作用就是，初始化时一个灯变绿，在一段时间后，变红，调用Lamp的turnOff方法 private Lamp currentLamp; public LampCotroller() { currentLamp=Lamp.南直行; currentLamp.light(); //初始化一个红路灯的开始状态. ScheduledExecutorService timer=Executors.newScheduledThreadPool(1); timer.scheduleAtFixedRate(new Runnable(){ public void run(){ currentLamp=currentLamp.turnOff(); } }, 10, 10, TimeUnit.SECONDS); } } //定义测试类 public class Test{ public static void main(String[] args){ String[] from = {&quot;东&quot;,&quot;西&quot;,&quot;南&quot;,&quot;北&quot;}; for(String temp : from){ new Roda(temp); } new LampCotroller(); } } 分析总结:分析:首先需求是要模拟十字路口交通灯管理系统.所以对对象,对象的方法等进行分析:名词提炼:有路,有车,有灯再提炼动作:车来,车过红绿灯,灯变化.所以抽象出的结论是:用集合抽象道路,枚举抽象红绿灯,一个操作类抽象灯控制器,一个描述类抽象汽车.下面是大体的实现步骤:1.定义路类集合.用来存储要过红绿灯的汽车.&lt;四&gt;2.定义灯枚举类,每个实例对象存在四大方向,每个方向有左转,右转,直行3个子属性,并且关联有对应转换方法.&lt;十二&gt;3.定义汽车描述类,具有来需要行进方向属,性即:要左行,要右行,要中行.&lt;一&gt;4.定义交通灯的控制类.初始化交通灯.5.定义测试类. 总结:首先不得不吐槽下,百度一下,关于交通管理系统这个关键词,就没看到其他不同的代码…跟视频里张老师的代码完全一样…严重怀疑多少人真正写过这个代码.虽然说这个代码不难.不过还是有点感叹,都太懒了… 然后就是我再做的过程中遇到的一些问题.1.定义Road时,用来存储汽车的集合我认为用LinkedList会更好. 因为 我觉得用LinkedList他有独特的addFist和removeLast方法,既符合实际情况,又在没有查询,只增删操作的情况下,提高了效率.(LinkedList底层为链表,ArrayList底层为数组) 2.我觉得应该抽象出来一个汽车描述类.这个类一旦实例化,就应该存在一个属性,就是行进的方向. 然后用出现在那条路上,拼接上车的行进方向确定所需要匹配的红绿灯.3.还有一个想法,暂时有些迷糊,记录下,稍后再探究. 就是我认为灯的枚举中,应该只有四个灯,而这四个灯中,应该分别有三个属性,就是左转,右转,直行,当然,如何体现,容我下回分解…Ps.今天是个特殊的日子,二十多年的辛苦打怪补兵,今天终于在老姐的助攻下,成功升级,辈分+1.以后也是有外甥的人了. 当然,更让我难以释怀的是,瞬间觉得任重道远起来…孩子,你舅舅我会好好混滴… 跟新:关于上面第三个想法,今天自己做了下,将红绿灯数目定为4个,因为事实上每个路口一个灯,只是这个灯中有左转,右转,直行三个成员属性. 还有事关于灯的控制系统,用亮红灯,亮绿灯来控制.下面是新写的代码: //定义测试类 public class Test{ public static void main(String[] args){ System.out.println(&quot;\t\t\t \t北\t &quot;); System.out.println(&quot;\t\t\t西\t+\t东&quot;); System.out.println(&quot;\t\t\t \t南\t &quot;); //红绿灯开始工作 new LampCotroller(); //车辆出现 String[] from = {&quot;东&quot;,&quot;西&quot;,&quot;南&quot;,&quot;北&quot;}; for(String temp : from){ new Road(temp); } } } //定义汽车类. public class Car{ //定义行进方向数组. static String[] towardsArr = {&quot;左转&quot;,&quot;直行&quot;,&quot;右转&quot;}; private int num; public String getInfo(){ return towards+num; } private String towards; public String getTowards(){ return towards; } //定义构造,车产生则明确行进方向. public Car(int num){ this.num = num; this.towards = towardsArr[new Random().nextInt(3)]; } } //定义枚举交通灯类 public enum Lamp{ 东(&quot;西&quot;,&quot;北&quot;,&quot;南&quot;), 西(&quot;东&quot;,&quot;南&quot;,&quot;北&quot;), 南(&quot;北&quot;,&quot;东&quot;,&quot;西&quot;), 北(&quot;南&quot;,&quot;西&quot;,&quot;东&quot;); //成员属性三个方向的等(true为绿灯,false为红灯): private boolean 左转 = false; private boolean 右转 = false; private boolean 直行 = false; //定义判断某行进方向是否为绿灯. public boolean isGreen(String towards) { switch (towards) { case &quot;直行&quot;: return 直行; case &quot;左转&quot;: return 左转; case &quot;右转&quot;: return 右转; default: return false; } } //对面路,交叉路灯指向. private String opposite; private String left; private String right; //初始化灯枚举实例. private Lamp(String opposite,String left,String right){ this.右转 = true; this.opposite = opposite; this.left = left; this.right = right; } //一个灯先直后左,对面路灯与之相同,垂直路灯与之相反, //定义变绿方法 public void transformGreen(){ 直行 = true; 左转 = false; //同步其他灯的状态 synch(); System.out.println(&quot;--------------------------------------------&quot;); System.out.println(this.name()+opposite+&quot;\t直行方向\t绿灯---左转方向\t红灯&quot;); System.out.println(right+left+&quot;\t直行方向\t红灯---左转方向\t绿灯&quot;); System.out.println(&quot;--------------------------------------------&quot;); } //定义变红方法 public void transformRed(){ 直行 = false; 左转 = true; //同步其他灯的状态. synch(); System.out.println(&quot;--------------------------------------------&quot;); System.out.println(this.name()+opposite+&quot;\t直行方向\t红灯---左转方向\t绿灯&quot;); System.out.println(right+left+&quot;\t直行方向\t绿灯---左转方向\t红灯&quot;); System.out.println(&quot;--------------------------------------------&quot;); } //定义私有方法,封装同步其他灯的装态 private void synch(){ Lamp.valueOf(opposite).直行 = 直行 ; Lamp.valueOf(opposite).左转 = 左转 ; Lamp.valueOf(left).直行 = !直行 ; Lamp.valueOf(left).左转 = !左转 ; Lamp.valueOf(right).直行 = !直行 ; Lamp.valueOf(right).左转 = !左转 ; } } //定义红绿灯控制器 public class LampCotroller { public LampCotroller() { // 指定一个初始化用红绿灯. ScheduledExecutorService timer = Executors.newScheduledThreadPool(1); timer.scheduleAtFixedRate(new Runnable() { @Override public void run() { if (Lamp.南.isGreen(&quot;直行&quot;)) {// 开启控制系统.必然有第一个灯是红或者绿的情况. Lamp.南.transformRed(); } else { Lamp.南.transformGreen(); } } }, 0, 10, TimeUnit.SECONDS); } } //定义道路 public class Road{ private LinkedList&lt;Car&gt; cars = new LinkedList&lt;Car&gt;(); private String name; public Road(String name){ this.name = name; //1到5秒随机产生一辆需要过红绿灯的车. ExecutorService pool = Executors.newSingleThreadExecutor(); pool.execute(new Runnable(){ public void run(){ int count = 1; while(true){ try { Thread.sleep((new Random().nextInt(10)+1)*1000); }catch (InterruptedException e) { e.printStackTrace(); } //出现一辆需要过红绿灯的车 cars.addLast(new Car(count++)); } } }); //定义一个定时器,每个1秒检查红绿灯状态,匹配该路上第一辆车行进方向为绿灯,则该车通行. ScheduledExecutorService timer = Executors.newScheduledThreadPool(1); timer.scheduleAtFixedRate(new Runnable(){ public void run(){ //当且仅当该路上有车时判断是否过红绿灯. if(cars.size()&gt;0){ //判断该车要去方向是否为绿灯.是则同行. if( Lamp.valueOf(Road.this.name).isGreen(cars.getFirst().getTowards())){ System.out.println(&quot;来自\t&quot;+Road.this.name+&quot;边\t&quot;+cars.removeFirst().getInfo()+&quot;号车辆\t行驶通过&quot;); } } } }, 1, 1, TimeUnit.SECONDS); } } 实现效果: ———————– android培训 、 java培训 、java学习型技术博客、期待与您交流！———————- 详情请查看：http://edu.csdn.net/]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>黑马程序员</tag>
        <tag>基础视频</tag>
        <tag>思路</tag>
        <tag>交通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-动态代理(面向切面)]]></title>
    <url>%2F2014%2F01%2F11%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86(%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2)%2F</url>
    <content type="text"><![CDATA[1.概述1.1.面向切面(AOP)思想系统中存在交叉业务，一个交叉业务就是要切入到系统中的某一个方面,比如多个类的共方法 例如:需要达到这样的效果:运行某个方法,在可以得到方法应有返回值的同时,可以知道该方法运行的时间. 交叉业务的编程问题即为面向方面的编程（Aspect oriented program ,简称AOP），AOP的目标就是要使交叉业务模块化. 可以采用将切面代码移动到原始方法的周围，这与直接在方法中编写切面代码的运行效果是一样的 使用代理技术正好可以解决这种问题，代理是实现AOP功能的核心和关键技术. 1.2.代理的概念要为已存在的多个具有相同接口的目标类的各个方法增加一些系统功能，例如，异常处理、日志、计算方法的运行时间、事务管理、等等，你准备如何做？ 编写一个与目标类具有相同接口的代理类，代理类的每个方法调用目标类的相同方法，并在调用方法时加上系统功能的代码。 如果采用工厂模式和配置文件的方式进行管理，则不需要修改客户端程序，在配置文件中配置是使用目标类、还是代理类，这样以后很容易切换, 譬如，想要日志功能时就配置代理类，否则配置目标类，这样，增加系统功能很容易，以后运行一段时间后，又想去掉系统功能也很容易。 2.java动态代理2.1.概述要为系统中的各种接口的类增加代理功能，那将需要太多的代理类，全部采用静态代理方式，不现实.JVM可以在运行期动态生成出类的字节码，这种动态生成的类往往被用作代理类，即动态代理类。JVM生成的动态类必须实现一个或多个接口，所以，JVM生成的动态类只能用作具有相同接口的目标类的代理。CGLIB库可以动态生成一个类的子类，一个类的子类也可以用作该类的代理，所以，如果要为一个没有实现接口的类生成动态代理类，那么可以使用CGLIB库。代理类的各个方法中通常除了要调用目标的相应方法和对外返回目标返回的结果外，还可以在代理方法中的如下四个位置加上系统功能代码：所以:功能代码可以是:在调用目标方法之前,在调用目标方法之后,在调用目标方法前后,在处理目标方法异常的catch块中. 2.2.Proxy类静态方法: static InvocationHandler getInvocationHandler(Object proxy) //返回指定代理实例的调用处理程序。 //(其实就是对被代理类所做的切面化操作.) static Class&lt;?> getProxyClass(ClassLoader loader, Class&lt;?>... interfaces) //返回代理类的 java.lang.Class 对象，并向其提供类加载器和参数列表接口数组。 //(通过这个Class对象的方法,可以获得一个代理类的实例) static boolean isProxyClass(Class&lt;?> cl) //当且仅当指定的类通过 getProxyClass 方法或 newProxyInstance 方法动态生成为代理类时，返回 true。 static Object newProxyInstance(ClassLoader loader, Class&lt;?>[] interfaces, InvocationHandler h) //返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序 2.3.字节尝试写一个代理类的代码:/* * 需求: * 写一个ArrayList类的代理，实现和ArrayList中完全相同的功能，并可以计算每个方法运行的时间。 * 思路: * 代理运用的是一种面向切面编程的思想.代理类在目标类的方法前,后,中的异常处理中嵌入其他功能方法等. * 这里想要创建一个ArrayList代理,可以直接使用java提供的动态代理来实现. * 步骤: * 1.建立Advice接口,定义代理添加的功能接口. * 2.建立接口实现类,实现计算每个方法运行时间的方法. * 3.通过Proxy类的静态方法建立获得ArrayList的一个基本动态类(具有和ArrayList相同的方法) * */ public class Test3 { public static void main(String[] args){ } } interface Advice{ public abstract void before(); public abstract void after(); } class MyAdvice implements Advice{ long start = 0; @Override public void before() { start = System.currentTimeMillis(); } @Override public void after() { long end = System.currentTimeMillis(); System.out.println("该方法运行时间为:"+(end-start)); System.out.print("方法返回:"); } } //按照Proxy提供的静态方法直接构建一个代理类 class ArrayListProxy{ public static void main(String[] args){ final ArrayList&lt;?> target = new ArrayList&lt;>(); final MyAdvice temp = new MyAdvice(); Collection collProxy = (Collection) Proxy.newProxyInstance(ArrayListProxy.class.getClassLoader(), ArrayList.class.getInterfaces(), new InvocationHandler() { // List &lt;?> listProxy = (List&lt;?>) Proxy.newProxyInstance(ArrayListProxy.class.getClassLoader(), new Class[]{List.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { temp.before(); Object obj = method.invoke(target, args); temp.after(); return obj; } }); ((ArrayList) collProxy).get(0); System.out.println(collProxy.size()); collProxy.add(null); collProxy.add("abc"); } } //按照逐步的方法尝试获得一个代理类 class ArrayListProxy_1{ public static void main(String[] args) throws Exception{ //获得代理类Class文件 Class clazz = Proxy.getProxyClass(ArrayListProxy_1.class.getClassLoader(), Collection.class); // Class clazz = Proxy.getProxyClass(ArrayListProxy.class.getClassLoader(), ArrayList.class); //Exception in thread "main" java.lang.IllegalArgumentException: java.util.ArrayList is not an interface // System.out.println(clazz); //通过Class文件获得实例对象 // Collection alProxy = (Collection) clazz.newInstance(); // System.out.println(alProxy); //Exception in thread "main" java.lang.InstantiationException: com.sun.proxy.$Proxy0 //无法被实例化,没有对应构造方法. //找构造 Constructor[] cons = clazz.getConstructors(); for( Constructor temp : cons){ System.out.println(temp); } //public com.sun.proxy.$Proxy0(java.lang.reflect.InvocationHandler) //用对应的构造,建立实例对象 //这里 Collection alProxy =(Collection)cons[0].newInstance(new InvocationHandler(){ // Collection&lt;?> alProxy =(Collection&lt;?>)cons[0].newInstance(new InvocationHandler(){ // ArrayList&lt;?> alProxy =(ArrayList)cons[0].newInstance(new InvocationHandler(){ ArrayList&lt;?> target = new ArrayList&lt;>(); @Override public Object invoke(Object alProxy, Method method, Object[] args) throws Throwable { MyAdvice temp = new MyAdvice(); temp.before(); System.out.println(temp.start); Object tempObj = method.invoke(target,args); temp.after(); return tempObj; }}); alProxy.add("abc"); System.out.println(alProxy); // alProxy.get(0); // 用不了子类的功能,只能用那个接口Collection中的方法. } } 3.总结在自己一步一步用不同方法写一个代理类出来的过程中,发现很多看上去明白了,但实际上只是连想都没开始想的问题. 1.参数列表中的接口Class参数首先就是构造一个代理类实例对象需要的那个Interface接口参数.老师,用的为Collection.class,结果就让我固定了思维,在需要做一个ArrayList代理是,毫不犹豫的将ArrayList实现的这个父类接口放了进去. 所以,就出现了我代码里测试的那样,这样得到的代理,在调用ArrayList的特有方法的时候,jvm编译时都无法通过,说不识别的方法名.还在考虑难道一个具体实现了某个接口的子类,拥有了父类没有的特有功能,那在代理中就无法使用,那样这代理还有什么意义? 最终在Class类中,找到了答案.Class类中提供了方法: getInterfacespublic Class&lt;?&gt;[] getInterfaces()确定此对象所表示的类或接口实现的接口。 通过Arraylist.class.getInterfaces(),得到的Class&lt;?&gt;[]作为参数构造出来的代理就解决了我刚开始遇到的问题. 2.在代理类中,对目标功能的封装在写代理类时,初期就是直接在InvocationHandler的方法中直接将操作代码写进去.后来,才发现可以将功能抽取,到时候在类中接收一个抽取出的接口的实例对象,调用需要增加的功能即可.大大增加可扩展性. 3.装饰设计模式and代理模式还有一点,就是冥冥中觉得,装饰设计模式跟代理(面向切面)的思想应该有很大的隐情,有一腿.前者,只不过是把需要功能进行增强的类的实例当作了一个构造的实例参数传入了包装类中.代理则干脆直接伪装成一个目标类,用户以为自己操作的是目标类,实际上是一个披了目标外表的代理类… 他们两者到底有什么关系?等想的有些头绪再跟新吧…]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>教程</tag>
        <tag>黑马程序员</tag>
        <tag>基础视频</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-反射 & JavaBean]]></title>
    <url>%2F2014%2F01%2F11%2F%E5%8F%8D%E5%B0%84%20%26%20JavaBean%2F</url>
    <content type="text"><![CDATA[1.Class类(字节码文件)1.1.概念理解Java类用于描述一类事物的共性，该类事物有什么属性，没有什么属性，至于这个属性的值是什么，则是由这个类的实例对象来确定的，不同的实例对象有不同的属性值。Java程序中的各个Java类，它们是否属于同一类事物，所以可以用一个类来描述这类事物,这个类的名字就是Class，要注意与小写class关键字的区别。 Class类描述了哪些方面的信息:类的名字，类的访问属性，类所属于的包名，字段名称的列表、方法名称的列表，等等。学习反射，首先就要明白Class这个类。 写如下代码进行对比理解：每个java类都是Class的一个实例对象，它们的内容不同，但是，它们的特征相同，譬如，都有方法，有字段，有父类，有包。 1.2.Class类获得方法类名.class 对象名.getClass();Class.forName(类名); 这三种方法,最常用的为第二种,第三种.第三种在后期可以通过配置文件读取,所以更为常用.第一中在反射方法的参数类型中常使用. 1.3.注意问题加载了字节码，并调用了其getMethods之类的方法，但是没有看到类的静态代码块被执行，只有在第一个实例对象被创建时，这个静态代码才会被执行。所以准确的说，静态代码块不是在类加载时被调用的，而是第一个实例对象时加载字节码被创建时才执行的。 1.4.Class类方法Class类 2.反射2.1.概念理解 反射就是把Java类中的各种成分映射成相应的java类。例如，一个Java类中用一个Class类的对象来表示，一个类中的组成部分：成员变量，方法，构造方法，包等等信息也用一个个的Java类来表示，就像汽车是一个类，汽车中的发动机，变速箱等等也是一个个的类。表示java类的Class类显然要提供一系列的方法，来获得其中的变量，方法，构造方法，修饰符，包等信息，这些信息就是用相应类的实例对象来表示，它们是Field、Method、Contructor、Package等等。一个类中的每个成员都可以用相应的反射API类的一个实例对象来表示，通过调用Class类的方法可以得到这些实例对象后可以通过将对象,参数作为该反射出来对象的参数,进行正向操作.2.2.构造.成员.方法的对应封装类 Constructor类:构造得到某个类所有的构造方法：例子：Constructor [] constructors= Class.forName(“java.lang.String”).getConstructors();得到某一个构造方法：例子： Constructor constructor = Class.forName(“java.lang.String”).getConstructor(StringBuffer.class);//获得方法时要用到类型创建实例对象：通常方式：String str = new String(new StringBuffer(“abc”));反射方式： String str = (String)constructor.newInstance(new StringBuffer(“abc”));//调用获得的方法时要用到上面相同类型的实例对象Class.newInstance()方法：例子：String obj = (String)Class.forName(“java.lang.String”).newInstance();该方法内部先得到默认的构造方法，然后用该构造方法创建实例对象。该方法内部的具体代码是怎样写的呢？用到了缓存机制来保存默认构造方法的实例对象。 Filed类:成员变量问题：得到的Field对象是对应到类上面的成员变量，还是对应到对象上的成员变量？类只有一个，而该类的实例对象有多个，如果是与对象关联，哪关联的是哪个对象呢？所以字段fieldX 代表的是x的定义(或者说声明)，而不是具体的x变量。所以,反射出的东西的操作,必须依托一个对象来体现.示例代码： ReflectPoint point = new ReflectPoint(1,7); Field y = Class.forName("cn.itcast.corejava.ReflectPoint").getField("y"); System.out.println(y.get(point)); //Field x = Class.forName("cn.itcast.corejava.ReflectPoint").getField("x"); Field x = Class.forName("cn.itcast.corejava.ReflectPoint").getDeclaredField("x"); x.setAccessible(true); System.out.println(x.get(point)); Method类:成员方法得到类中的某一个方法：例子： Method charAt = Class.forName(“java.lang.String”).getMethod(“charAt”, int.class);调用方法：通常方式：System.out.println(str.charAt(1));反射方式： System.out.println(charAt.invoke(str, 1));如果传递给Method对象的invoke()方法的第一个参数为null，这有着什么样的意义呢？说明该Method对象对应的是一个静态方法！jdk1.4和jdk1.5的invoke方法的区别(可变参数)：Jdk1.5：public Object invoke(Object obj,Object… args)Jdk1.4：public Object invoke(Object obj,Object[] args)，即按jdk1.4的语法，需要将一个数组作为参数传递给invoke方法时，数组中的每个元素分别对应被调用方法中的一个参数，所以，调用charAt方法的代码也可以用Jdk1.4改写为 charAt.invoke(“str”, new Object[]{1})形式。 4.数组的反射3.反射—-内省—-JavaBean3.1.概念 JavaBean是一种特殊的Java类，主要用于传递数据信息，这种java类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果要在两个模块之间传递多个信息，可以将这些信息封装到一个JavaBean中，这种JavaBean的实例对象通常称之为值对象（Value Object，简称VO）。这些信息在类中用私有字段来存储，如果读取或设置这些字段的值，则需要通过一些相应的方法来访问，大家觉得这些方法的名称叫什么好呢？JavaBean的属性是根据其中的setter和getter方法来确定的，而不是根据其中的成员变量。如果方法名为setId，中文意思即为设置id，至于你把它存到哪个变量上，用管吗？如果方法名为getId，中文意思即为获取id，至于你从哪个变量上取，用管吗？去掉set前缀，剩余部分就是属性名，如果剩余部分的第二个字母是小写的(就代表是定义get,set方法是将首字母大写了)，则把剩余部分的首字母改成小的。 3.2.涉及到的几个类和接口Introspector: The Introspector class provides a standard way for tools to learn about the properties, events, and methods supported by a target Java Bean.(我理解他就像一个静态方法库一样的概念,给想要运用内省操作的其他类或者接口等提供静态方法支持) MethodDescriptor:A MethodDescriptor describes a particular method that a Java Bean supports for external access from other components. (我理解就是,一个该类的实例对象,就是封装某些信息,描述某些个符合JavaBean规则的类的某个成员属性的赋值获取等方法的信息)PropertyDescriptor:(目前不知道MethodDescriptor什么用,有空上网研究下) A PropertyDescriptor describes one property that a Java Bean exports via a pair of accessor methods.(我的理解就是,一个该类的实例对象,就是疯涨了描述一个符合JavaBean规则的类的某个成员属性的信息) BeanInfo:A bean implementor who wishes to provide explicit information about their bean may provide a BeanInfo class that implements this BeanInfo interface and provides explicit information about the methods, properties, events, etc, of their bean. (这个就是每个实例就是封装了所有的跟某个成员属性相关的变量声明,方法(赋值,获取方法),等.每个BeanInfo应该对应一对存储器,一个PropertyDescriptor,一个MethodDescriptor.)他们之间的关系: 我们可以通过对一个类,调用Introspector中的静态方法,获得他类中所有的BeanInfo(返回值理所当然是个数组.).在通过BeanInfo方法,可以选择性的拿到PropertyDescriptor. 然后再通过PropertyDescriptor中的方法,可以执行对该属性的赋值.或者了解各种信息.(下面第二个代码用的就是这写步骤) 3.3.代码 /* 需求: 学习内省,JavaBean的使用 */ import java.beans.*; import java.lang.reflect.*; class Student{ private String name; private int age; // public void setName(String name){ // this.name=name; // } public void setAge(int age){ this.age = age; } // public String getName(){ // return name; // } public int getAge(){ return age; } } class JavaBeanDemo{ public static void main(String[] args)throws Exception{ Student s1 = new Student(); //JavaBean的内省方式设置属性值. // Student s1 = new Student(); // String propertyName = "name"; // PropertyDescriptor pd = new PropertyDescriptor(propertyName,s1.getClass()); // Method methodSetName = pd.getWriteMethod(); // Method methodGetName = pd.getReadMethod(); // methodSetName.invoke(s1,"高富帅"); // System.out.println(methodGetName.invoke(s1)); //反射方式设置属性值. Class studentClass = Class.forName("Student"); Field name = studentClass.getDeclaredField("name"); name.setAccessible(true); name.set(s1,"屌丝"); // System.out.println(s1.getName()); System.out.println(name.get(s1)); } } package com.back.han; import java.beans.BeanInfo; import java.beans.Introspector; import java.beans.PropertyDescriptor; import java.lang.reflect.Method; /** * 存在一个JavaBean，它包含以下几种可能的属性： 1:boolean/Boolean 2:int/Integer 3:String * 4:double/Double 属性名未知，现在要给这些属性设置默认值，以下是要求的默认值： String类型的默认值为字符串 * www.itheima.com int/Integer类型的默认值为100 boolean/Boolean类型的默认值为true * double/Double的默认值为0.01D. * 只需要设置带有getXxx/isXxx/setXxx方法的属性，非JavaBean属性不设置，请用代码实现 * */ public class Test6 { public static void main(String[] args) { try { Bean bean = new Bean(); init(bean); System.out.println(bean); } catch (Exception e) { e.printStackTrace(); } } private static Bean init(Bean bean) throws Exception { // TODO Auto-generated method stub BeanInfo bi = Introspector.getBeanInfo(bean.getClass()); PropertyDescriptor[] pds = bi.getPropertyDescriptors(); for (PropertyDescriptor pd : pds) { Method rm = pd.getWriteMethod(); if (String.class == pd.getPropertyType()) { rm.invoke(bean, "www.itheima.com"); } else if (int.class == pd.getPropertyType()) { rm.invoke(bean, 100); } else if (boolean.class == pd.getPropertyType()) { rm.invoke(bean, true); } else if (double.class == pd.getPropertyType()) { rm.invoke(bean, 0.01d); } } return bean; } } class Bean { String company; int number; boolean good; double cash; public String getCompany() { return company; } public void setCompany(String company) { this.company = company; } public int getNumber() { return number; } public void setNumber(int number) { this.number = number; } public boolean isGood() { return good; } public void setGood(boolean good) { this.good = good; } public double getCash() { return cash; } public void setCash(double cash) { this.cash = cash; } @Override public String toString() { return "Bean [company=" + company + ", number=" + number + ", good=" + good + ", cash=" + cash + "]"; } }]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>黑马程序员</tag>
        <tag>基础视频</tag>
        <tag>反射</tag>
        <tag>内省</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-泛型(浅识)]]></title>
    <url>%2F2014%2F01%2F11%2F%E6%B3%9B%E5%9E%8B(%E6%B5%85%E8%AF%86)%2F</url>
    <content type="text"><![CDATA[(部分内容,知其然,不知其所以然,先记下,慢慢品) 题外话: 开始学习张孝祥老师的基础加强视频,发现,自以为学的不错,其实就像只是用300cc的瓶子去接了250cc的水.倘若倒入1000cc的瓶子中,一下就觉得空荡荡了.学习过程是给300cc瓶子灌水的过程.灌水的过程固然重要,适当的升级瓶子更是必不可少.感谢张孝祥老师. 再次缅怀已逝的张孝祥老师. 1.泛型基本知识术语 ArrayList:泛型类型ArrayList中的E:称为类型变量或类型参数 ArrayList:称为参数化的类型ArrayList中的Integer:称为类型参数的实例或实际类型参数 ArrayList中的&lt;&gt; 为: type ofArrayList:称为原始类型 1.1.参数化类型与原始类型的兼容性参数化类型可以引用一个原始类型的对象，编译报告警告 例如， Collection c = new Vector();原始类型可以引用一个参数化类型的对象，编译报告警告 例如， Collection c = new Vector(); 1.2.参数化类型不考虑类型参数的继承关系Vector v = new Vector(); Vector v = new Vector(); 1.3.编译器不允许创建泛型变量的数组即在创建数组实例时，数组的元素不能使用参数化的类型. 例如，下面语句有错误： Vector vectorList[] = new Vector[10];注:老师这里说的不能定义泛型变量数组,是赋值两边都加泛型,其实,我试了下,在数组变量的声明上加上泛型是可以的. Vector vectorList[] = new Vector [10];Vector vectorList[] = new Vector[10]; 2.泛型中的？通配符2.1由一个问题引入：定义一个方法，该方法用于打印出任意参数化类型的集合中的所有数据，该方法如何定义呢？ public static void printCollection(Collection&lt;Object> cols) { for(Object obj:cols) { System.out.println(obj); } cols.add("string");//没错 cols = new HashSet&lt;Date>();//这里相当于这样:Collection&lt;Object> cols = new HashSet&lt;Date>(). } 正确方式： public static void printCollection(Collection&lt;?> cols) { for(Object obj:cols) { System.out.println(obj); } cols.add("string"); //错误，因为它不知自己未来匹配就一定是String. //相当于:new Collection&lt;?>().add(?) 而传入String.这样就会强制让前面的?变为String了 cols.size(); //没错，此方法与类型参数没有关系 cols = new HashSet&lt;Date>(); } 2.2.总结使用?通配符可以引用其他各种参数化的类型，?通配符定义的变量主要用作引用，可以调用与参数化无关的方法，不能调用与参数化有关的方法。 2.3.扩展限定通配符的上边界 正确：Vector&lt;? extends Number&gt; x = new Vector();错误：Vector&lt;? extends Number&gt; x = new Vector();限定通配符的下边界正确：Vector&lt;? super Integer&gt; x = new Vector();错误：Vector&lt;? super Integer&gt; x = new Vector(); 2.4.注意限定通配符总是包括自己。?只能用于引用泛型,不能用于赋值. Vector&lt;? extends Number&gt; y = new Vector&lt;Integer&gt;(); Vector&lt;Number&gt; x = y;//虽然此时的y的确元素类型都为Integer,但是他的包装还是&lt;? extends Number&gt;,所以不行 //相当于 Vector &lt;Number&gt; x = new Vector &lt;? extends Number &gt;(); 上面的第二行代码错误，原理与Vector x11 = new Vector();相似，这个时候只能通过强制类型转换方式来赋值。 3.定义泛型方法假设需求:定义一个泛型方法交换数组中的两个元素的位置的泛型方法语法定义如下：static void swap(E[] a, int i, int j) {E t = a[i];a[i] = a[j];a[j] = t;} //或用一个面试题讲：把一个数组中的元素的顺序颠倒一下 注意:a.只有引用类型才能作为泛型方法的实际参数，swap(new int[3],3,5);语句会报告编译错误。b.除了在应用泛型时可以使用extends限定符，在定义泛型时也可以使用extends限定符，例如，Class.getAnnotation()方法的定义。并且可以用&amp;来指定多个边界， 如: void method(){}c.普通方法、构造方法和静态方法中都可以使用泛型。d.也可以用类型变量表示异常，称为参数化的异常，可以用于方法的throws列表中，但是不能用于catch子句中。e.在泛型中可以同时有多个类型参数，在定义它们的尖括号中用逗号分例如：public static V getValue(K key) { return map.get(key);} 4.类型参数的类型推断(待理解…)编译器判断范型方法的实际类型参数的过程称为类型推断，类型推断是相对于知觉推断的，其实现方法是一种非常复杂的过程。 l根据调用泛型方法时实际传递的参数类型或返回值的类型来推断，具体规则如下：当某个类型变量只在整个参数列表中的所有参数和返回值中的一处被应用了，那么根据调用方法时该处的实际应用类型来确定，这很容易凭着感觉推断出来，即直接根据调用方法时传递的参数类型或返回值来决定泛型参数的类型，例如： swap(newString[3],3,4) à static void swap(E[] a,int i, int j) 当某个类型变量在整个参数列表中的所有参数和返回值中的多处被应用了，如果调用方法时这多处的实际应用类型都对应同一种类型来确定，这很容易凭着感觉推断出来，例如： add(3,5) àstatic T add(T a, T b) 当某个类型变量在整个参数列表中的所有参数和返回值中的多处被应用了，如果调用方法时这多处的实际应用类型对应到了不同的类型，且没有使用返回值，这时候取多个参数中的最大交集类型，例如，下面语句实际对应的类型就是Number了，编译没问题，只是运行时出问题： fill(newInteger[3],3.5f) àstatic void fill(T[] a, T v) 当某个类型变量在整个参数列表中的所有参数和返回值中的多处被应用了，如果调用方法时这多处的实际应用类型对应到了不同的类型，并且使用返回值，这时候优先考虑返回值的类型，例如，下面语句实际对应的类型就是Integer了，编译将报告错误，将变量x的类型改为float，对比eclipse报告的错误提示，接着再将变量x类型改为Number，则没有了错误： int x=(3,3.5f) àstatic T add(T a, T b) 参数类型的类型推断具有传递性，下面第一种情况推断实际参数类型为Object，编译没有问题，而第二种情况则根据参数化的Vector类实例将类型变量直接确定为String类型，编译将出现问题： copy(new Integer[5],newString[5]) à static void copy(T[] a,T[] b); copy(new Vector(), newInteger[5]) à static void copy(Collection a , T[] b); 5.定义泛型类型如果类的实例对象中的多处都要用到同一个泛型参数，即这些地方引用的泛型类型要保持同一个实际类型时，这时候就要采用泛型类型的方式进行定义，也就是类级别的泛型，语法格式如下： public class GenericDao&lt;T>{ private T field1; public void save(T obj){} public T getById(int id){} } 类级别的泛型是根据引用该类名时指定的类型信息来参数化类型变量的，例如，如下两种方式都可以： GenericDaodao =null;new genericDao(); 注意：在对泛型类型进行参数化时，类型参数的实例必须是引用类型，不能是基本类型。 当一个变量被声明为泛型时，只能被实例变量、方法和内部类调用，而不能被静态变量和静态方法调用。因为静态成员是被所有参数化的类所共享的，所以静态成员不应该有类级别的类型参数。所以,类中只有一个方法需要使用泛型，直接使用方法级别的泛型就行了.否则代码的容错性降低了… 6.泛型的继承继承时，对泛型父类的类型参数不实例化 class A&lt;E>{ ArrayList&lt;E> temp = new ArrayList&lt;>(); } class B&lt;E> extends A&lt;E>{ ArrayList&lt;E> temp = new ArrayList&lt;>(); } 继承时，对泛型父类的类型参数实例化 class A&lt;E>{ ArrayList&lt;E> temp = new ArrayList&lt;>(); } class B&lt;F> extends A&lt;String>{ ArrayList&lt;F> temp = new ArrayList&lt;>(); } 7.通过反射获得泛型的参数化类型示例代码： Class GenericalReflection { private Vector&lt;Date> dates = newVector&lt;Date>(); public void setDates(Vector&lt;Date> dates) { this.dates = dates; } public static void main(String[] args) { Method methodApply = GenericalReflection.class.getDeclaredMethod("applyGeneric", Vector.class); ParameterizedType pType = (ParameterizedType) (methodApply .getGenericParameterTypes())[0]; System.out.println("setDates(" + ((Class) pType.getRawType()).getName() + "&lt;" + ((Class) (pType.getActualTypeArguments()[0])).getName() + ">)" ); } } 8.泛型简单使用总结(张老师的了解相当深入,暂时只吸收5成…下面是我觉得在普通使用中会能够应付的简单总结) 泛型优点安全–不需要强制转换–将运行阶段问题放到编译阶段解决 参数化类型使用(赋值语句中)规律:“=”两边,同时又&lt;&gt;,则&lt;&gt;中内容必须完全相同.其他一概不考虑… “=”两边,又一边出现泛型,随意.(但有个特例:数组的泛型定义,只能将&lt;&gt;放在声明上,就是左边) 在类上定义泛型在类上定义了一个泛型,对于在类上定义的泛型，我们在整个类内都可以使用.可以在方法上，可以在属性上，但是不能在静态方法中应用。 在方法上定义泛型在任意的方法上都能声明泛型，但是泛型必须加在方法的返回值前。 泛型中的通配符使用? extends E 它代表的是E类型或E的子类这个在Collection接口中的addAll(Collection&lt;? extends E&gt; c)? super E 它代表的是E类型或E的父类 泛型的擦除属性泛型只是在编译阶段有效果，当运行后它就失去作用。]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
        <tag>基础视频</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-简单网络编程总结]]></title>
    <url>%2F2014%2F01%2F11%2F%E7%AE%80%E5%8D%95%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[题外话:其实原本感觉网络编程和IO流结合,有些小迷糊.但是再在硬着头皮装B给别人答疑时,自己把自己给捋顺了…所以,装B也是一种高效学习法… 1.网络编程概述1.1.概念：通过编程语言实现计算机键的数据通信。 1.2.网络编程的三要素：A:Ip地址: 是计算机的唯一标识点分十进制。IP地址的分类。IP地址的组成。ipconfig pingB:端口物理端口：网线插口,亲… 逻辑端口：用于标识进程的逻辑地址,不同进程的标识;有效端口：0~65535,其中0~1024系统使用或保留端口.范围：0-65535(0-1024之间一般系统被占用.)C:协议:是定义的通信规则 UDP(面向无连接):将数据源和目的封装成数据包中，不需要建立连接；每个数据报的大小在限制在64k；因无连接，是不可靠协议；不需要建立连接，速度快. TCP(面向连接): 建立连接，形成传输数据的通道；在连接中进行大数据量传输；通过三次握手完成连接，是可靠协议；必须建立连接，效率会稍低 注:关于InetAddress类的使用:(最需要记的就下面这个代码:) import java.net.*; class IPDemo{ publicstatic void main(String[] args) throws UnknownHostException{ //通过名称(ip字符串or主机名)来获取一个ip对象。 InetAddressip = InetAddress.getByName("www.baidu.com");//java.net.UnknownHostException System.out.println("addr:"+ip.getHostAddress()); System.out.println("name:"+ip.getHostName()); } } 2.UDP协议传输2.1.DatagramSocket和DatagramPacket:只要是网络传输,必须有socket .数据一定要封装到数据包中,数据包中包括目的地址,端口,数据等信息. DatagramSocket:直接操作udp不可能，对于java语言应该将udp封装成对象，易于我们的使用，这个对象就是DatagramSocket. 封装了udp传输协议的socket对象。DatagramSocket具备发送和接受功能，在进行udp传输时，需要明确一个是发送端，一个是接收端。 DatagramPacket:因为数据包中包含的信息较多，为了操作这些信息方便，也一样会将其封装成对象。这个数据包对象就是：DatagramPacket.通过这个对象中的方法，就可以获取到数据包中的各种信息。 2.2.代码体现,学习过程:发送端: import java.net.*; import java.io.*; /* 操作步骤: 1. 创建udp socket ,建立端点.(指定监视的端点) 2. 定义数据包(字节数组),并通过receive方法接收数据包. 3.通过数据包的方法,获取其中的数据. 4.将信息反馈给控制台. 5.读到结束符,886则读取结束.关闭资源. */ //创建接收端类 class ReceiveDemo{ public static void main(String[] args) throws IOException{ //创建发送端Socket服务对象,这里指定了端口,要监视特定端口传递来的数据 DatagramSocket ds = new DatagramSocket(19999); //定义用于接收数据包的字节数组 byte[] rec = new byte[1024]; DatagramPacket dp = new DatagramPacket(rec,rec.length);//创建数据包. while(true){ ds.receive(dp); InetAddress address = dp.getAddress(); String ip = address.getHostAddress(); byte[] rec2 = dp.getData(); int length = dp.getLength(); String s = new String(rec2,0,length);//这里之所以要强调数据的长度,是因为传递是一个完整的1024字节的包.没有信息的用空格补齐了. if(s.equals("886")){ break; } System.out.println(address +"---"+ ip +"---"+ s); } ds.close(); } } 接收端: import java.net.*; import java.io.*; /* 步骤: 1.创建udp服务,通过DatagramSocket对象. 2.确定数据源,并进行封装,封装成数据包. 3.通过socket服务,将已有的数据包发送出去,通过send方法. 4.关闭已经打开的资源. */ //创建接收端类: class SendDemo{ public static void main(String[] args){ try { DatagramSocket ds = new DatagramSocket(); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line = null; while((line=br.readLine())!=null&amp;&amp;!line.equals("over")){ byte[] arr = line.getBytes(); DatagramPacket dp = new DatagramPacket(arr,arr.length,InetAddress.getByName("192.168.3.255"),19999); ds.send(dp); } ds.close(); } catch (Exception e) { } } } 3.TCP传输3.1.概述:两个端点的建立连接后会有一个传输数据的通道，这通道称为流，而且是建立在网络基础上的流，称之为socket流。该流中既有读取，也有写入。tcp的两个端点：一个是客户端，一个是服务端。客户端：对应的对象，Socket服务端：对应的对象，ServerSocket 3.2.代码体现,学习过程服务器端: /* 需求: 练习使用TCP传输方法传输数据 TCP服务器步骤: 1.创建服务器端的Socket对象. 2.设置一个监听,用来监听连接.(保证客户端可以进行连接) 3.Socket流中获取输入流,输出流,进行数据传输. 4.释放资源. TCP客户端步骤: 1.创建客户端的Socket对象. 2.建立与服务器连接, 3.从Socket流中获取输入输出流,进行数据传输. 4.释放资源. */ import java.io.*; import java.net.*; //建立TCP服务器端 class TCPServer{ public static void main(String[] args)throws Exception{ //建立服务器端的socket服务. ServerSocket ss = new ServerSocket(19999); //此时为阻塞状态,等待获取客户端的连接. Socket s = ss.accept(); //只有上一步得到了该客户端的连接对象才能进下一步. InetAddress address = s.getInetAddress(); String ip = address.getHostAddress(); System.out.println(address+"---"+ip+"连接中---"); //通过从Socket流中获取输入输出流,可以进行数据传输. //读取流中的客户端的socket对象的输入输出流. BufferedInputStream br = new BufferedInputStream(s.getInputStream()); BufferedOutputStream bw = new BufferedOutputStream(new FileOutputStream("abcCopy.jpg")); BufferedWriter bw2 = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); //拿到输入输出流进行数据操作. byte[] arr = new byte[1024]; int len = 0; while((len=br.read(arr))!=-1){ bw.write(arr,0,len); bw.flush(); } bw.close(); //发送反馈信息 bw2.write("数据成功接收"); bw2.newLine(); bw2.flush(); //br.close(); //s.close(); } } 客户端: /* 需求: 练习TCP客户端的搭建使用 */ import java.io.*; import java.net.*; //搭建TCP数据传输的客户端 class TCPClient{ public static void main(String[] args)throws Exception{ //建立客户端的Socket对象. Socket s = new Socket("127.0.0.1",19999); //为Socket套接字中投入一个输入流(要不然不是一个源都没有,他怎么形成流?可以是键盘输入,可以是读取问文件等等) BufferedInputStream br = new BufferedInputStream(new FileInputStream("abc.gif")); //获得该Socket套接字的输入输出流(两边的互通交流in对应out,out对应in) BufferedOutputStream bw = new BufferedOutputStream(s.getOutputStream()); BufferedReader brServer = new BufferedReader(new InputStreamReader( s.getInputStream())); ////获得流对象,进行数据操作. //int ch = 0; //while((ch=bis.read())!=-1){ //bos.write(ch); //} byte[] arr = new byte[1024]; int len = 0; while((len=br.read(arr))!=-1){ bw.write(arr,0,len); bw.flush(); } br.close(); s.shutdownOutput(); //获得服务器的反馈信息. String server = brServer.readLine();//阻塞 System.out.println("server:" + server); s.close(); } } 4.关于套接字一直以为套接字,套接流就是一种管道流. 后来才发现两个是两码事.但我还是觉得,套接字的表现形式很像管道流: Socket服务器的连接动作,就像是封装了管道流的in,out对接的两个动作. Socket中的getINput(Output)就像是管道流中的Input(Output). 彼端的in,对应此端的out;此端的in,对应笔端的out… 相当的神似…可能就是一种互通思想的多态表现形式吧…..]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
        <tag>知识点</tag>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-重要代码记录Part2(持续跟新)]]></title>
    <url>%2F2014%2F01%2F10%2F%E9%87%8D%E8%A6%81%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95Part2(%E6%8C%81%E7%BB%AD%E8%B7%9F%E6%96%B0)%2F</url>
    <content type="text"><![CDATA[黑马程序员-重要代码记录(原打算一个帖子收集,发现多了就不方便回顾,特另开) 1.关于猫狗鱼问题的思路我的代码: import java.util.ArrayList; import java.util.Random; public class Cross_new { public static void main(String[] args) { //开始过河. doTransport(); } public static void doTransport() { // 抽象出猫,鱼,狗和两岸. ArrayList&lt;String> arr1 = new ArrayList&lt;String>(); ArrayList&lt;String> arr2 = new ArrayList&lt;String>(); arr1.add("鱼"); arr1.add("猫"); arr1.add("狗"); // 农夫将要携带到船上动物.(前一字符表示农夫当前携带动物,后一字符表示上次农夫携带的动物,为了让农夫不出现重复拿同一个动物的情况) System.out.println("农夫,猫,鱼,狗都在此岸,开始过河.\n"); String boat = new String("--"); while (arr1.size() > 0) { move(arr1, arr2, boat); } System.out.println("\n农夫,猫,鱼,狗都到达彼岸."); } public static void move(ArrayList&lt;String> arr1, ArrayList&lt;String> arr2,String boat) { //农夫船上是否有动物,有则不需随机选择携带. if (boat.startsWith("-")) { int one=0; do{ // 农夫从此岸随机带上一个动物. one = new Random().nextInt(arr1.size()); }while(arr1.get(one)==boat.substring(1, 2)); boat = arr1.get(one)+boat.substring(1,2); arr1.remove(one); } // 判断此岸是否和谐 if (ifNice(arr1)) { // 此岸和谐,农夫则将动物送去彼岸. arr2.add(boat.substring(0, 1)); System.out.println("--->农夫带" + boat.substring(0, 1) + "去彼岸 "); //首先判断是否将三个动物都放彼岸,是则无需判断是否和谐. if(arr2.size()==3){ return; } // 判断彼岸是否和谐. if (ifNice(arr2)) { // 彼岸和谐,农夫则完成此次运送. boat="-"+boat.substring(0, 1); System.out.println(" 农夫单独回此岸&lt;---"); } else { // 彼岸不和谐,农夫则将岸上动物与携带动物交换.送回此岸. boat=arr2.get(0)+boat.substring(0, 1); System.out.println(" 农夫带" +boat.substring(0, 1)+ "回此岸&lt;---"); arr2.remove(0); arr1.add(boat.substring(0, 1)); boat="-"+boat.substring(0, 1); } } else { // 如果此岸不和谐则放回此岸. arr1.add(boat.substring(0, 1)); boat="-"+boat.substring(0,1); } } public static boolean ifNice(ArrayList&lt;String> arr) {// 判断是能否共存. if ((arr.contains("猫") &amp;&amp; arr.contains("狗")) || (arr.contains("鱼") &amp;&amp; arr.contains("猫"))) { return false; } else { return true; } } } 朋友的代码: public class Test10_1 { public static void main(String[] args) { // 首先创建三个对象 Animal cat = new Cat("cat"); Animal dog = new Dog("dog"); Animal fish = new Fish("fish"); // 定义两个链表存放对象 LinkedList&lt;Animal> beforeCrossing = new LinkedList&lt;Animal>(); LinkedList&lt;Animal> afterCrossing = new LinkedList&lt;Animal>(); beforeCrossing.add(cat); beforeCrossing.add(dog); beforeCrossing.add(fish); while (beforeCrossing.size() != 0) { // 从beforeCrossing取出一个Animal Animal ani = beforeCrossing.removeFirst(); // 如果剩下两个Animal，看看剩下的Animal能否和平共处 if (beforeCrossing.size() == 2) { if (beforeCrossing.getFirst().friendlyWith(beforeCrossing.getLast())) { // 如果能合同共处，把取出的动物送到afterCrossing afterCrossing.addLast(ani); System.out.println(ani.getName() + "被送到对岸"); } else { // 如果剩下的动物不能和平共处，则把取出的Animal再次插入beforeCrossing beforeCrossing.addLast(ani); } } else { // 否则先把动物送到对岸 afterCrossing.addLast(ani); System.out.println(ani.getName() + "被送到对岸"); // 再判断对岸的Animal能否和平共处 if (afterCrossing.size() == 2) { // 如果不能和平共处，则把对岸的原先的动物给送回来 if (!afterCrossing.getFirst().friendlyWith(afterCrossing.getLast())) { ani = afterCrossing.removeFirst(); beforeCrossing.addLast(ani); System.out.println(ani.getName() + "被送了回来"); } } } } } } abstract class Animal { private String name; public Animal() { super(); } public Animal(String name) { super(); this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public abstract boolean friendlyWith(Animal ani); } class Cat extends Animal { public Cat() { super(); // TODO Auto-generated constructor stub } public Cat(String string) { super(string); } @Override public boolean friendlyWith(Animal ani) { if (ani.getClass().getSimpleName().equals("Dog") || ani.getClass().getSimpleName().equals("Fish")) return false; else return true; } } class Dog extends Animal { public Dog() { super(); // TODO Auto-generated constructor stub } public Dog(String string) { super(string); } @Override public boolean friendlyWith(Animal ani) { if (ani.getClass().getSimpleName().equals("Cat")) return false; else return true; } } class Fish extends Animal { public Fish() { super(); // TODO Auto-generated constructor stub } public Fish(String string) { super(string); } @Override public boolean friendlyWith(Animal ani) { if (ani.getClass().getSimpleName().equals("Cat")) return false; else return true; } } 总结:这道题是从黑马基础题上看到的,刚开始以为没什么知识点,纯if判断就ok.后来才发现,可以很有知识点,1.我再上面放出的第一个代码是我的思路.第二个是以朋友的思路. 我的代码在一开始,就没有我朋友的那种相当浓烈的面向对象思想.他将猫狗鱼都封装成了类,继承动物类,有方法Friendly.对于Java的面向对象思想来说,貌似很切合.我的代码思路就是抽象了两岸,小船,用集合和String[]抽象了他们,并将动物抽象为了字符数组中的字符.虽然,我自认为自己的方法看起来更简单,但是不得不承认,思想上,败给了朋友的代码. 所以,我觉得Java前期的学习,必须注重思维的培养,培养面向对象的思想,深化封装,继承,多态的思维模式.有了思想,语言基础都是可以用时间补上的…. 2.按字节为截取字符代码引发的思考我的代码: /* * 需求: * 编写函数，从一个字符串中按字节数截取一部分，但不能截取出半个中文（GBK码表） * 例如：从“HM程序员”中截取2个字节是“HM”，截取4个则是“HM程”，截取3个字节也要是"HM"而不要出现半个中文. * * 思路: * 字符串的字节文件表示中,英文字母为一个byte型数据表示,而汉子为两个byte数据表示. * 对给定的一个字符串,用toCharArray()和getByte()方法分别转换为字符,字节数组. * 如果是字母,则对应数组中元素的数值应该是相等的,否则不等,且为字节数组中两个元素对应字符数组中一个元素. * * 步骤: * 1.键盘录入一个字符串对象. * 2.转换并接受用String类中方法得到的字符数组与字节数组. * 3.键盘接收需要截取字符串的字节数. * 4.以字节数组元素来判定截取字节数,以与字符串数组元素的对比判断是否该将对应字符截取. * 5.打印出截取后字符串. * */ public class Test10 { public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.println("请输入需要截取的字符串:"); String str = in.nextLine(); subPartOfString(str); } //定义方法,按需求截取字符串中对应字节字符串. public static void subPartOfString(String str) { Scanner in = new Scanner(System.in); char[] charArr = str.toCharArray(); byte[] byteArr = str.getBytes(); int n = 0; while (true) { System.out.println("请输入需要截取字节数:(数字)"); n = in.nextInt(); if (n > byteArr.length || n &lt;= 0) { System.out.println("输入的截取字节数有误,请重新输入."); continue; } else { break; } } int j = 0, i = 0, count = 1;//i用于控制截取字节数,即循环增量;j为截取后字符数. while (i &lt; n) { if (charArr[j] - byteArr[i] == 0) {//如果当前字节位为字母,则加入截取后字符串. i++; j++; } else {//如果当前字节为汉子,则占两个字节,当且仅当截取了两个字节才将该字符加入截取后字符串. count++; i++; j += count % 2; } } System.out.println("截取后新字符串为:\n"+new String(charArr, 0, j)); } } 张孝祥老师的方法代码: public class TEST{ public static void main(String[] args) throws Exception{ String str = "我a爱中华abc我爱传智def"; String str = "我ABC汉"; int num = trimGBK(str.getBytes("GBK"),5); System.out.println(str.substring(0,num)); } public static int trimGBK(byte[] buf,int n){ int num = 0; boolean bChineseFirstHalf = false; for(int i=0;i&lt;n;i++) { if(buf[i]&lt;0 &amp;&amp; !bChineseFirstHalf){ bChineseFirstHalf = true; }else{ num++; bChineseFirstHalf = false; } } return num; } } 总结: 在这里,先对已逝的张孝祥老师报以有种的感谢…您一路走好.这道题,也是从黑马入学基础题目中侬到的题目.在自己解决的时候,对如何判断是否截取这个占用了两个字节的一个汉子字符相当繁琐,多定义了两个集合,多用了几个循环增量.在看张孝祥老师的就业面试宝典时,突然发现,这道题老师的代码,很好. 我是这么顺着老师的代码走的思路:1.方法定义中的参数列表为:一个由目标字符串转换成的字节数组,截取的字节数. 2.方法中,在循环截取的代码外,定义了截取长度的初始值0 ,一个判断是否为中文字符的布尔变量.for循环的判断中,用字节数据是否为负数 (汉子由两个负的字节数据组成)和是否截取过1个字符的前一个字节. 在循环体结束(两处,if和else)中分别对该辅助判断的布尔变量进行新的赋值 . 4.返回该结果.事实上,我自己的代码中思路何老师差不多,但是没能思路明了的用一个布尔型变量来接收.实际上就是封装了我代码中的循环增量判断和赋值.其实想想也是,当循环增量是以模2为判断辅助条件,用false,或true,完全可以既简便由明了的替代这个循环增量. 总之,学习老师等高手的思想,思路,路还很长…]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>黑马程序员</tag>
        <tag>知识点</tag>
        <tag>思路</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-IO总结]]></title>
    <url>%2F2014%2F01%2F10%2FIO%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[题外话:这近十天来.为了赶进度,越来越发现自己没有花多少时间去总结回顾之前的知识了.突然发现IO流已经学习完几天了.竟然一次也没复习过.甚至于提到IO某些知识都有种莫名的陌生感. 的确时间不等人,但是某些必要的时间还是得划出来.更不能因为周边某些人的急功近利,反而乱了自己的节奏. 不断的戒掉旧习,却又不断的有新的恶习. 想优秀,要努力. 1.I/O概述1.1.I/O系统顾名思义:输入/输出系统. I/O之所以公认最重要,就是因为作为输入输出,就是输入输出的源端和想要与之通信的接收端(对应Input,Output)存在各种形式.而且还需要考虑各种不同的数据类型作为源和接收端之间的数据能否互通问题. 2.准备工作-File类2.1.File类的概念一个实用类库工具,用于帮助处理文件内部数据外的文件,文件夹,路径等属性. 其实就是将文件系统中的文件和文件夹封装成了对象.提供了更多的属性和行为可以对这些文件和文件夹进行操作.这些是流对象办不到的,因为流只操作数据. 2.2.File类的常用构造和方法File类 (更新下,今天用到了一个相当常用,当时学习File没有写进去,罪过)重命名 boolean f1.renameTo(Filedest);//可以实现移动的效果.剪切+重命名. 注意: 这里的renameTo()方法,改变了需要改变的文件夹后,他的f1封装的还是以前未改的路径,就不是在指向改后的文件或文件夹了!!! 我在这里栽了很蛋疼的跟头.谨记.!! 2.3.案例这里最经典就是用递归思想操作一个目标文件下,包括子文件的所有文件及文件夹.我的代码: /* * 需求: * 编写程序，将指定目录下所有.java文件拷贝到另一个目的中，并将扩展名改为.txt * * 思路: * 封装原始与目的路径对象,利用递归的方式获取原始目录下java文件路径对象. * 然后每当获取到java文件路径对象,通过IO流中的字符流在目的路径创建java文件对应txt文件进行复制. * * 步骤: * 1.键盘录入初始目录路径,目标目录路径,并进行封装. * 2.自定义复制java文件方法,按需求,复制.java文件并改后缀名为.txt. * 3.自定义遍历方法,利用递归的方式,获取初始目录下所有java文件路径对象. * 4.每当获取到java文件路径对象,调用自定义复制方法,进行复制. * 5.反馈操作是否成功. * */ public class Test9 { public static void main(String[] args){ Scanner in = new Scanner(System.in); System.out.println("您将进行如下操作:\n\t将指定目录下所有.java文件拷贝到另一个目的中，并将扩展名改为.txt\n请输入初始路径:\t(例如:D:/itheima/javaCode)"); String fromStr=in.nextLine(); System.out.println("请输入目标路径:\t(例如:E:/itheima/txtCode)"); String targetStr=in.nextLine(); //封装初始路径,目标路径. File from=new File(fromStr); File target=new File(targetStr); //判断目标路径是否存在,否则创建. if (!target.exists()) { System.out.println("目标路径不存在,自动创建."); target.mkdirs(); } //调用方法,复制重命名文件. copyAll(from, target); System.out.println("拷贝并重命名操作成功!"); } //定义遍历方法,用递归方式遍历目录下所有java文件,并调用自定义复制方法进行复制. private static void copyAll(File from,File target){ File[] fileList=from.listFiles(); for(File temp : fileList){ if(temp.isDirectory()){//如果该路径对象是文件夹,则递归. File targetTemp=new File(target,temp.getName()); targetTemp.mkdirs(); copyAll(temp,targetTemp); }else{ if(temp.getName().endsWith(".java")){//如果该路径对象是文件,判断是否为java文件,是则调用方法,自定义复制. try { myCopy(temp,target); } catch (IOException e) { System.exit(0); } } } } } //定义复制java文件方法,包括将文件后缀改为txt操作. private static void myCopy(File from,File target) throws IOException { File targetFile=new File(target,from.getName().replace(".java", ".txt"));//修改复制后文件后缀为txt. BufferedReader br=null; BufferedWriter bw=null; try { br=new BufferedReader(new FileReader(from)); bw=new BufferedWriter(new FileWriter(targetFile)); String temp=null; while((temp=br.readLine())!=null) {//运用字符缓冲流,复制java文件进入目标路径下同名txt文件. bw.write(temp); bw.newLine(); } } catch (IOException e) { throw e; } finally{//关闭资源. if(bw!=null) try { bw.close(); } catch (IOException e) { throw e; } finally{ if(br!=null) try { br.close(); } catch (IOException e) { throw e; } } } } } 3.IO流体系3.1.IO流分类流的概念:可以理解数据的流动,就是一个数据流.IO流最终要以对象来体现.对象都存在IO包中. 流的分类两种依据处理方式不同:分为输入流(读)和输出流(写). 处理的数据不同:分为字节流和字符流.(下面是四大基类)字节流：InputStream OutputStream 字符流：Reader Writer 字节流: 处理字节数据的流对象。设备上的数据无论是图片或者dvd，文字，它们都以二进制存储的。二进制的最终都是以一个8位为数据单元进行体现，所以计算机中的最小数据单元就是字节。意味着，字节流可以处理设备上的所有数据，所以字节流一样可以处理字符数据。 字符流: 因为字符每个国家都不一样，所以涉及到了字符编码问题，那么GBK编码的中文用unicode编码解析是有问题的，所以需要获取中文字节数据的同时+ 指定的编码表才可以解析正确数据。为了方便于文字的解析，所以将字节流和编码表封装成对象，这个对象就是字符流。只要操作字符数据，优先考虑使用字符流体系。 3.2.字符流：Reader：用于读取字符流的抽象类。子类必须实现的方法只有 read(char[], int, int) 和 close()。 |—BufferedReader：从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。 |—InputStreamReader：是字节流通向字符流的桥梁：它使用指定的字符集读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。 |—FileReader：用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream 上构造一个 InputStreamReader。 Writer：写入字符流的抽象类。子类必须实现的方法仅有 write(char[], int, int)、flush() 和 close()。 |—BufferedWriter：将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 |—OutputStreamWriter：是字符流通向字节流的桥梁：可使用指定的字符集将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。 |—FileWriter：用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。要自己指定这些值，可以先在 FileOutputStream 上构造一个 OutputStreamWriter。 |—PrintWriter：字符打印流. 3.3.字节流InputStream：是表示字节输入流的所有类的超类。 |— FileInputStream：从文件系统中的某个文件中获得输入字节。哪些文件可用取决于主机环境。FileInputStream 用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用 FileReader。 |— BufferedInputStream：该类实现缓冲的字节输入流。 |— ObjectInputStream：用于序列化的操作流.将对象存入字节文件中进行存储或者传输. |— PipedInputStream：管道流. OutputStream：此抽象类是表示输出字节流的所有类的超类。 |— FileOutputStream：文件输出流是用于将数据写入 File或 FileDescriptor的输出流。 |— FilterOutputStream：此类是过滤输出流的所有类的超类。 |— BufferedOutputStream：该类实现缓冲的输出流。 |— PrintStream：字节打印流. |— ObjectOutputStream：用于反序列化的操作流.将存入文件中的对象数据读取出来获得该对象实例. |— PipedOutputStream：管道输出流. 3.4.流的操作规律：1，明确源和目的。 数据源：就是需要读取，可以使用两个体系：InputStream、Reader； 数据汇：就是需要写入，可以使用两个体系：OutputStream、Writer； 2，操作的数据是否是纯文本数据？ 如果是：数据源：Reader 数据汇：Writer 如果不是：数据源：InputStream 数据汇：OutputStream 3，虽然确定了一个体系，但是该体系中有太多的对象，到底用哪个呢？ 明确操作的数据设备。 数据源对应的设备：硬盘(File)，内存(数组)，键盘(System.in) 数据汇对应的设备：硬盘(File)，内存(数组)，控制台(System.out)。 4，需要在基本操作上附加其他功能吗？比如缓冲。 如果需要就进行装饰。 4.缓冲区(或者叫高效流)4.1.理解原理缓冲区其实就是底层用数组,将需要读取的数据进行缓存,当达到一定量后进行写入或者读取. 说白了就是读一大片,写一大片. 4.2.模拟自定义BufferedReader(BufferedInputStream等其他高效流类似) 我的代码: /* 需求: 利用装饰设计模式,模仿jvm底层实现BufferedReader或者BufferedWriter的方式,自定义读写缓冲区. 思路: 缓冲区其实就是对默认的字符输入输出流(FileReader和FileWriter)字节输入输出流进行功能修饰. 用到了装饰设计模式. 步骤: 1.自定义方法,参数列表为需要的输入或者输出流. 2.将作为参数传递的输入输出流Read或者Writer方法进行缓冲区功能性加强. 3.封装自定义方法类.作为自定义缓冲区类. */ import java.io.*; class MyBufferedReader{ //为了让整个类都能调用fr的方法进行装饰. private FileReader fr; MyBufferedReader(FileReader fr){//让该类一旦实例化,必然存在一个FileReader对象. this.fr = fr; } //定义读取一行的方法. public String readLine()throws IOException{ int ch = 0; StringBuilder line=new StringBuilder(); while((ch=fr.read())!=-1){ if (ch=='\r'){ if ((ch=fr.read())=='\n'){//同时遇到 return line.toString(); }else{ // line.append('\r'); //如果单单遇到\r而不是\r\n,就把\r放进读取的字符串中. } } line.append((char)ch); } if (line.length()!=0)//当读到结尾,line中还存在数据的话,就返回这些数据. return line.toString(); return null; } //定义关闭资源方法. public void close()throws IOException{ fr.close(); } } class MyBufferedReaderTest { public static void main(String[] args)throws IOException{ MyBufferedReader mbr = new MyBufferedReader(new FileReader("abc.txt")); String line = null; while((line=mbr.readLine())!=null){ System.out.println(line); } mbr.close(); } } 4.3.注意:字符流的缓冲流中提供了readLine()和newLine()方法. 而字节流的缓冲流中没有提供.需要注意. 5.转换流5.1.转换流概念转换流特有功能：转换流可以将字节转成字符，原因在于，将获取到的字节通过查编码表获取到指定对应字符。 转换流最重要的内容就是:字节流 + 编码表 —&gt;字符流.事实上,没有转换流，就没有字符流。 InputStreamReader-----------&gt;底层为字节流 |--FileReader-------------------&gt;我们应用为字符流 OutputStreamWriter----------&gt;底层为字节流 |--FileWrier---------------------&gt;我们应用为字符流 所以, 想要操作文本文件,必须要进行编码转换,而编码转换动作转换流都完成了.所以操作文件的流对象只要继承自转换流就可以读取一个字符了. 但是子类有一个局限性，就是子类中使用的编码是固定的，是本机默认的编码表，对于简体中文版的系统默认码表是GBK。 **FileReaderfr = new FileReader(&quot;a.txt&quot;); 等同于 ****InputStreamReaderisr = new InputStreamReader(newFileInputStream(&quot;a.txt&quot;),&quot;gbk&quot;);** 如果仅仅使用平台默认码表，就可以直接使用**:********FileReader fr = new FileReader(&quot;a.txt&quot;); ** 如果需要制定码表,必须用转换流. 转换流 = 字节流+编码表. 转换流的子类File = 字节流 + 默认编码表(GBK). 5.2.代码实例: 案例： //键盘录入数据 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferddWriter bw = new BufferedWriter(new FileWriter("a.txt")); String line = null while((line=br.readLine())!=null) { if("over".equals(line)) { break; } bw.write(line); bw.newLine(); bw.flush(); } bw.close(); br.close(); //把文本文件的数据通过流对象在控制台显示 BufferedReader br = new BufferedReader(new FileReader("a.txt")); BufferddWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String line = null while((line=br.readLine())!=null) { bw.write(line); bw.newLine(); bw.flush(); } bw.close(); br.close(); 6.打印流6.1.打印流概念:打印流是写数据的.6.2.特点：A:可以写任意数据类型的数据 B:如果启动了自动刷新，能自动刷新，还会换行。println()C:可以直接往文件写数据 注意：看构造方法，一个流对象的构造中如果同时有String和File的构造参数，那么该流对象就可以读写文件。 6.3.用打印流改进复制文本文件的操作(PrintStream可应用于二进制文件) //数据源： //c:\\a.txt //目的地： //d:\\b.txt BufferedReader br = new BufferedReader(new FileReader("c:\\a.txt")); PrintWriter pw = new PrintWriter(new FileWriter("d:\\b.txt"),true); String line = null; while((line=br.readLine())!=null) { pw.println(line); } pw.close(); br.close(); 7.字符编码7.1.编码表：就是字符和对应的数据组成的一张表。 7.2.常见的编码表：ASCIIISO-8859-1GBKGB2310GB18030UTF-8BIG5 7.3.转换流中的编码问题A:字符流 = 字节流+编码表B:通过转换流写入数据，指定为UTF-8编码，并通过UTF-8编码读取。 8.存储程序对象信息.8.1.通过Properties,序列化存储.Properties: 通过键值对的形式,将对象的属性名,属性值作为键值对映射的方式存入Map中.(Properties:为Map的实现类) 序列化: 通过ObjectInputStream流将实现了序列化接口的类实例化对象以二进制数据的形式写入文本文件中 A: setProperty(String key,String value) B:getProperty(String key) getProperty(String key,String defaultValue) C:Set&lt;String&gt; stringPropertyNames() 和IO流结合的方法： A:list 通过打印流把数据保存到文件中 B:load 通过任意流把文本中的数据加载到集合中 C:store 通过任意流把数据保存到文件中]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
        <tag>基础视频</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-重要代码记录Part1(end)]]></title>
    <url>%2F2014%2F01%2F06%2F%E9%87%8D%E8%A6%81%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95Part1(end)%2F</url>
    <content type="text"><![CDATA[黑马程序员-重要代码记录 1.返回两个字符串的共有最大长度子字符串. /* 需求分析:返回两个字符串的最大长度相同字符串. 思路: 1.录入两个字符串. 2.用循环以短的那个字符串长度n为循环次数. 3.再循环的n次中,建立内循环,循环从短的那个数组的0索引开始,长度从1到段数组的长度结束.定义新字符串. 4.进行判断该字符串是否在较长字符串中. 5返回循环结束后的那个新字符串. */ class MaxSubString { public static void main(String[] args) { //录入两个字符串. String s1="awsxe3dcrfvtgbythnujmikd"; String s2="gfdcrfxfgghgefs"; System.out.println(getMaxSubString(s1,s2)); } //定义方法,获取两个字符串的共有最大长度字符串. private static String getMaxSubString(String s1,String s2) { for (int x=0;x&lt;s2.length();x++)//外循环定义用来辅助内循环定义新字符串的长度. { for (int y=0,z=s2.length()-x;z&lt;s2.length();y++,z++) //通过对x的引用,控制y,z之间的字符串长度固定,这样,通过外循环控制长度避免索引越界和遍历不完全. { String temp=s2.substring(y,z); if (s1.contains(temp)) { // System.out.println(temp); return temp; } } } return ""; } } 总结: 最开始做这道题,总是在如何确定for循环的初始化条件和控制循环终点条件.最后发现,还是得通过列举出实际情况,在实际情况中寻找规律.所以,关于那个思维记录贴中的第二篇Note还是相当有价值的. **因为是要截取共有最大长度子字符串.所以确定长度必然小于短的子字符串. 然后,用y,z(就是s2.length()-x),来定义每次内循环来截取字符串的首尾索引.相当于两个游标,游标之间长度固定,在短字符串中向末尾依次移位,看是否为相同子字符串.**2.控制台打印给定日期日历. /* 需求: 通过键盘录入的年月日,打印出当月日历. 分析: 这里要用到1990,1,1日作为定位基点.某年某月某日减去1990,1,1日得到的天数模7的值即为星期几. 步骤: 1.键盘录入年月日. 2.通过for循环和if判断语句,累加天数. 3.通过辅助日期1990,1,1日得到该月第一天的星期数. 4.绘制日历表头,定位当月第一天在一周中的位置. 5.打印日历. */ import java.util.*; class Date { public static void main(String[] args){ //键盘录入年月日. System.out.println("\t\t日历查询\t\t"); Scanner in=new Scanner(System.in); System.out.println("请输入年份："); int year=in.nextInt(); System.out.println("请输入月份："); //int mouth=in.nextInt(); int mouth=in.nextInt(); System.out.println("请输入日期："); int day=in.nextInt(); System.out.println("您输入的是"+year+"年"+mouth+"月"+day+"日"); int sum=0; //判断所输入年份，计算整年离1990年的天数 for(int a=1990;a&lt;year;a++){ if(a%4==0&amp;&amp;a%100!=0||a%400==0){ sum=sum+366; continue; } sum=sum+365; } //判断所输入月份，计算整月份离元月一号的天数 for(int b=1;b&lt;mouth;b++){ if(b==2){ if(year%4==0&amp;&amp;year%100!=0||year%400==0){ sum=sum+29; continue; }else{ sum=sum+28; continue; } }else if(b==4||b==6||b==9||b==11){ sum=sum+30; continue; } sum=sum+31; } /* //整年，整月天数，加上输入日期即是总共离1990年元月一日的天数 sum=sum+day; System.out.println("这一天距离1990年，元月，一日总共"+sum+"天"); } */ //绘制日历表头,定位当月第一天在一周中的位置. System.out.println("\t\t日历开始打印"); System.out.println("日\t一\t二\t三\t四\t五\t六"); //确定第一天，就是所选择日期月份第一天是周几,此时sum已经被注释过了，就是已经是单年份，月份，天数总和 sum=sum+1; //进行月份的判断，将月份天数确定，赋值给m int m; if (mouth==2){ if (year%4==0&amp;&amp;year%100!=0||year%400==0){ m=29; } m=28; }else if (mouth==4||mouth==6||mouth==9||mouth==11){ m=30; }else{ m=31; } //此时的天数对7取余，余数是几，就是周几,并将1号定位并打印 for (int i=1;i&lt;=sum%7;i++){//将打印日历循环做出，循环M次 System.out.print(" \t"); } for (int n=1;n&lt;=m;n++){ if (sum%7==6){ System.out.println(n+"\n"); sum++; continue; } sum++; System.out.print(n+"\t"); } System.out.println(); } } 总结: 学习java基础语法部分时,总是对循环有种莫名的恐惧 ,对于循环的控制条件难以把握.日历打印题目是从网上看到的.拿来通过分析,思路,代码实现,相当有成就感.虽然现在回头发现很多需要改进,但是在入门期多做这样的联系还是相当有帮助的. 下面是后期学习了新知识的改进版(面向对象的思想渐渐深入,将方法尽量封装): import java.util.Scanner; /* 需求:建立一个简易的日历查询工具,输入需要查询的年月,在控制台打印该月日历(带星期). 分析:首先判断所输入日期的月份天数.在判断当月第一天星期数.再打印. 思路: 1.定义一个方法,给定年月日参数来打印日历. 2.键盘录入年月日,调用方法打印日历. */ public class DateSearch { public static void main(String[] args) { Scanner in=new Scanner(System.in); System.out.println("请输入想打印月份月历的年,月.\n请输入年份:"); int year=in.nextInt(); System.out.println("请输入月份:(1~12)"); int month=in.nextInt(); System.out.println("当前年份天数为:"+getYear(year)); System.out.println("当前月份天数为:"+getMonth(month,year)); printDate(year,month); } public static boolean ifRun(int year) {//建立方法,判断是否闰年. if ((year%4==0&amp;&amp;year%100!=0)||year%400==0) { return true; } return false; } //判断并返回当年天数. public static int getYear(int year) { return ifRun(year)?366:365; } //建立方法,判断并返回当月天数. public static int getMonth(int month,int year) { if (month==2) { if (ifRun(year)) { return 29; } return 28; }else if (month==4||month==6||month==9||month==11) { return 30; }else{ return 31; } } //建立方法,返回需要判断天数的星期数(星期日为0) public static int getWeekday(int days) { return(days%7); } //定义方法,打印当月日历.. public static void printDate(int year,int month) { int sum=0; for (int i = 1990; i &lt; year ; i++) {//这里,因为1990,1月1日为周一,拿来做参照. if(ifRun(year)){ sum+=366; }else{ sum+=365; } } for (int i = 1; i &lt;month; i++) { sum+=getMonth(i,year); } System.out.println("日\t一\t二\t三\t四\t五\t六\t\n-----------------------------------------"); System.out.print(sum+"\n"); for (int i=1;i&lt;=sum%7;i++){ System.out.print(" \t"); } for (int n=1;n&lt;=getMonth(month,year);n++){ if (sum%7==6){ System.out.print(n+"\n"); sum++; continue; } sum++; System.out.print(n+"\t"); } } } 3.学习循环链表的建立与使用链表类:(定义循环链表的方法类,包括创建,遍历,功能等) /* 需求:学习循环链表的建立与使用 思路: 循环链变在于他每个对象内,有两部分组成,地址域和首地址. 每个元素的地址域指向链表中的他的下一个地址.而首地址则是他本个元素的对象的地址. 步骤: 1.建立第一个对象,对象内部定义下一个对象的指向. 2.建立构造函数,构造对象,如果为第一个对象,额外定义一个用来指向下一个对象的temp对象,用来保存需要传递的地址值. 3.如果是最后一个对象,则将其temp中的传递的地址值,指向第一个对象. */ public class CycLink { //首先建立第一个成员的引用.就是将环形链表的头,定义. Member firstMember=null; Member temp=null; //定义成员数量. //测试类中使用的变量 int num=0; int a=0;//play功能中,从那个结点开始. int b=0;//报数到b,此人踢出. CycLink(){} //设置环形链表的长度,就是结点的个数 public void setNum(int num){ this.num=num; } public void setA(int a){ this.a=a; } public void setB(int b){ this.b=b; } //初始化,建立循环链表. public void createLink(){ for (int i = 1; i &lt;= num; i++) { if (i==1) { //创建成员. Member m=new Member(i+"号"); this.firstMember=m; temp=firstMember; }else if(i!=num){ Member m=new Member(i+"号"); temp.nextMember=m; temp=m; }else{ Member m=new Member(i+"号"); temp.nextMember=m; m.nextMember=firstMember; } } } //定义测试类中用到的约瑟夫问题具体使用 public void play(){ Member play =this.firstMember; System.out.println(play); for (int i = 1; i &lt;a; i++) { play=play.nextMember; System.out.println(play); } while(play.nextMember!=play){ for (int i = 1; i &lt;b-1; i++){ play=play.nextMember; System.out.println(play); } Member tempplay=play.nextMember; // System.out.println(play); //tempplay=tempplay.nextMember; play.nextMember=tempplay.nextMember; System.out.println("-----------------------"); System.out.println(play+"\t踢掉报数为5的人."+tempplay.getName()); System.out.println("-----------------------"); play=play.nextMember; System.out.println(play); } System.out.println(play); } //遍历循环链表 public void printCycLink(){ Member start=this.firstMember; do{ System.out.println(start); start=start.nextMember; }while(start!=firstMember); System.out.println("遍历结束,回到循环链表起始处"); } } 结点类:(封装每个结点包含的自身属性和指向属性) public class Member {//环形链表中的元素,其实就是结点.应当包括其对象特有属性和一个结点特有的应用型指向,就是地址域. private String name; Member nextMember=null; Member(){} Member(String name){ this.name=name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString(){ return name+"\t指向为:\t"+nextMember.name; } } 测试类:(测试循环列表的创建,遍历增删是否正常,并可以结合具体问题实施) public class CycLinkTest { public static void main(String[] args) { CycLink cy=new CycLink();//定义一个新的循环链表 cy.setNum(20);//设置循环链表的长度. cy.createLink();//创建次循环链表. cy.setA(1);//设置开始结点. cy.setB(5);//设置报何数踢出. cy.play(); //cy.printCycLink();//遍历打印循环链表. } } 总结:循环链表是在学习集合说到LinkedList集合底层是链表结构时想到的循环链表名词.结合之前做过的报数退出(约瑟夫问题),想到的高端实现方法. 循环链表的建立我发现其实再使用上对于现有的集合而言,有自己的独特优势:在某些需要实时跟新集合,反馈集合信息进行后续执行的情况下,循环链表具有先天优势:增删快. 而他的弊端则在,循环链表需要人为定义初始结点,查找指定元素相对于其他所有集合都没有优势,必须从初始结点一个个向下找.下面是关于约瑟夫问题我用循环的解答:(相对于用循环链表解答繁琐和很多.) /* 有n个人围成一圈，顺序排号。从第一个人开始报数（从1到m报数），凡报到m的人退出圈子，问最后留下的是原来第几号的那位。求算法思路 */ import java.util.Scanner; public class YueSeFu { public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.println("请输入人数n和数到m出列的n,m值:"); System.out.println("请输入n(大于0的整数):"); int n = in.nextInt(); System.out.println("请输入m(大于0的整数):"); int m = in.nextInt(); System.out.println("第" + getEnds(n, m) + "个人为最后留下来的人."); } public static int getEnds(int n, int m) { int[] arr = new int[n];// 建立一个长度为n的int型数组,元素为每个人的编号(标号为数组索引+1) for (int i = 1; i &lt;= arr.length; i++) { arr[i - 1] = i; } int cycle = 0, cut = 0, i = 0;// 声明两个辅助循环的增量,cycle为循环数;cut为提出圈人数. for (i = 1; i &lt;= arr.length; i++) { if (arr[i - 1] != 0) { cycle++; } if (cycle == m) { arr[i - 1] = 0; cycle = 0; cut++; } if (cut &lt;= arr.length - 1){ // 判断条件,因为cut为最终终止循环的增量,所以先判断 if (i == arr.length){// 判断为不终止循环的基础上,判断是否为循环最后一个数据,是,则给i赋值0,使之i++后重新为1,进入新一轮循环. i = 0; continue; } } else { break; } } return i; } } 4.蛇形数组(相当锻炼思维) /* * 需求: * 写一个方法,打印等长的二维数组,要求从1开始的自然数由方阵的最外圈向内螺旋方式的顺序排列.如:n=4,打印: * 1 2 3 4 * 12 13 14 5 * 11 16 15 6 * 10 9 8 7 * 思路分析: * 1.观察,可知需求的二维数组中元素应该对应所打印每个数据.行,及n为二维数组的长度及其中每个一位int型一维数组的长度. * 2.同时,观察得到具体每个int型元素是由行,列边界值完全遍历,再到边界值-1完全遍历...直到填满整个二维数组. * 实现步骤: * 1.建立一个每个int型一维数组长度为n,二维数组长度也为n的二维数组. * 2.遍历赋值. * 3.打印. */ public class SnakeArray { public static void main(String[] args) { printArray(3); System.out.println("\n------------分-----割-----线------------\n\n"); printArray(7); } //定义一个按照需求打印二维数组的方法,参数为int型n. public static void printArray(int n) { int[][] arr=new int[n][n]; int x=1; //arr[0][0] for(int p=0;p&lt;n/2;p++){ //arr[0][0]>>arr[0][n-2] for (int i = p; i &lt; n-1-p; i++) { arr[p][i]=x++; } //arr[0][n-1]>>arr[n-2][n-1] for (int j = p; j &lt; n-1-p;j++) { arr[j][n-1-p]=x++; } //arr[n-1][n-1]>>arr[n-1][1] for(int i=n-1-p;i>p;i--){ arr[n-1-p][i]=x++; } //arr[n-1][0]>>arr[1][0] for(int j=n-1-p;j>p;j--){ arr[j][p]=x++; } //arr[1][0]>>arr[1][1]之后循环上述过程,即可完成偶数n的赋值. } //若n为奇数,则需要对忽略位置[n/2][n/2]进行赋值. if (n%2!=0) { arr[n/2][n/2]=x; } //打印数组. for (int i = 0; i &lt; n; i++) { for(int j=0;j&lt;n;j++){ System.out.print("\t"+arr[i][j]+"\t"); } System.out.println("\n---------------------------------------------\n" ); } } } 总结: 通过这次分析蛇形数组,虽然用循环做出了最终答案,但是后来发现这明显用到了递归的思想.所以等面试落定,我再用递归方法来改进下.5.控制台五子棋代码. import java.util.Random; import java.util.Scanner; public class WuZiQi { static Scanner in = new Scanner(System.in); public static void main(String[] args) { printBoard(); } // 选手落子. public static void printBoard() { String[][] board = new String[10][10]; for (int i = 0; i &lt; board.length; i++) { for (int j = 0; j &lt; board[i].length; j++) { board[i][j] = " + "; System.out.print(board[i][j]); } System.out.println(); } A: while (true) {// 判断若输入点已有棋子,则重新输入. int x, y; while (true) { System.out.println("请落子:(输入落子坐标值1~10)"); x = in.nextInt() - 1; y = in.nextInt() - 1; if (ifRight(x) &amp;&amp; ifRight(y)) break; System.out.println("输入的棋子位置异常,请重新输入."); } if (board[x][y].equals(" ● ") || board[x][y].equals(" O ")) { System.out.println("此处已有棋子,请重新落子:"); continue; } else { board[x][y] = " ● "; } /* * for (int i = 0; i &lt; board.length; i++) {// 打印棋盘. for (int j = 0; * j &lt; board[i].length; j++) { System.out.print(board[i][j]); } * System.out.println(); } */ print(board); int count = 0; while (count != 1) { System.out.println("电脑落子,请稍等..."); Random r1 = new Random(); int xC = r1.nextInt(9) + 1; int yC = r1.nextInt(9) + 1; /* * int xC = new Random().nextInt(9) + 1; int yC = new * Random().nextInt(9) + 1; */ // int xC =(int)Math.random()*10+1; // int yC = (int) Math.random() * 10 + 1; // //为什么用Math里的random不行??? if (board[xC][yC].equals(" O ") || board[xC][yC].equals(" ● ")) { System.out.println("此处已有棋子,请重新落子:"); continue; } else { board[xC][yC] = " O "; count = 1; } /* * for (int i = 0; i &lt; board.length; i++) {// 打印棋盘. for (int j = * 0; j &lt; board[i].length; j++) { System.out.print(board[i][j]); * } System.out.println(); } */ print(board); } // 判断输赢条件. String resoult1 = ""; String resoult2 = ""; String resoult3 = ""; String resoult4 = ""; for (int i = 0; i &lt; board.length; i++) {// 判断横行,竖行出现五连. for (int j = 0; j &lt; board[i].length; j++) { resoult1 += board[i][j]; resoult2 += board[j][i]; } if (resoult1.contains(" ● ● ● ● ● ") || resoult2.contains(" ● ● ● ● ● ")) { System.out.println(" ● 选手赢了"); break A; } else if (resoult1.contains(" O O O O O ") || resoult2.contains(" O O O O O ")) { System.out.println(" O 选手赢了"); break A; } else { resoult1 = ""; resoult2 = ""; } } /* * for (int i = 0, j = 0; i &lt;= 4 &amp;&amp; j &lt;= 4; i++, j++) { resoult3 += * board[i][j]; } */ for (int i = 0; i &lt;= 4; i++) {// 判断右斜是否出现五连 int a = i; for (int j = 0; j &lt;= 4; j++) { int b = j; while (true) { resoult3 += board[a][b]; resoult4 += board[b][a]; a++; b++; if (a == 9 || b == 9) { a = i; b = j; break; } } if (resoult3.contains(" ● ● ● ● ● ") || resoult4.contains(" ● ● ● ● ● ")) { System.out.println(" ● 选手赢了"); break A; } else if (resoult3.contains(" O O O O O ") || resoult4.contains(" O O O O O ")) { System.out.println(" O 选手赢了"); break A; } else { resoult3 = ""; resoult4 = ""; } } } for (int i = 0; i &lt;= 4; i++) {// 判断左斜是否出现五连 int a = i; for (int j = 9; j > 4; j--) { int b = j; while (true) { resoult3 += board[a][b]; resoult4 += board[9 - a][b]; a++; b--; if (a == 9 || b == 0) { a = i; b = j; break; } } if (resoult3.contains(" ● ● ● ● ● ") || resoult4.contains(" ● ● ● ● ● ")) { System.out.println(" ● 选手赢了"); break A; } else if (resoult3.contains(" O O O O O ") || resoult4.contains(" O O O O O ")) { System.out.println(" O 选手赢了"); break A; } else { resoult3 = ""; resoult4 = ""; } } } } } private static boolean ifRight(int x) {// 判断用户输入的数据转化成的数组索引是否合理 return (x >= 0 &amp;&amp; x &lt;= 9) ? true : false; } public static void print(String[][] board) { // System.out.println( " 1 2 3 4 5 6 7 8 9 ⑩"); for (int i = 0; i &lt; board.length; i++) {// 打印棋盘. for (int j = 0; j &lt; board[i].length; j++) { System.out.print(board[i][j]); } System.out.println(); } } } 总结:写这个代码的最初原因是在学习疯狂JAVA书的时候,看他了作者在书中提到的用二维数组可以实现在控制台上布置五子棋棋盘. 然后便突然想用控制台做出一个可以跟电脑一起下五子棋的控制台程序.现在存在的问题:电脑没有落子的优先级.(思考后,认为可以这样,定义一个枚举类,元素为可能出现的2,3,4连的棋子情况,判断当前棋盘是否存在枚举中元素,有则在其首位落子.无则先现在实现的那样,random落子) 5.表象文件隐藏其他文件 /* 需求: 通过复制的追加模式,将两个文件中的指定文件用另一文件隐藏. 通过反向读取将上述方法的隐藏文件与表象文件分离. 思路: 文件的复制有追加模式,而追加模式如果在一个已经具有文件格式的文件上进行,则会在不改变该文件表面属性 的基础上,将需要隐藏文件的数据追加在其后. 对于一个用某文件隐藏了目标文件的文件,通过从去表面文件结尾开始截取可以进行还原. 步骤: 1.给定两个文件,表象文件(最好为图片):用来确定隐藏信息文件的表现形式.指定隐藏文件:需要在表象文件下隐藏的文件. 2.定义方法,先创建表象文件副本,而后在副本以追加模式写入需隐藏文件. 3.定义方法,将隐藏信息文件进行分解,需要用表象文件来辅助定位开始截取位置. 4.保存截取后文件(即原带隐藏文件). */ import java.io.*; import java.util.Scanner; class CoverInfo { public static void main(String[] args) throws IOException { Scanner in = new Scanner(System.in); System.out.println("请输入隐藏文件所用表象文件路径:"); String outerStr = in.nextLine(); System.out.println("请输入隐藏文件路径:"); String innerStr = in.nextLine(); System.out.println("请输入隐藏文件完成后存储路径:"); String targetStr = in.nextLine(); File outer = new File(outerStr); File inner = new File(innerStr); File target = new File(targetStr); coverInfo(outer, inner, target); } // 定义隐藏文件方法. private static void coverInfo(File outer, File inner, File target) throws IOException { if (!outer.isFile() || !inner.isFile()) { System.out.println("文件不存在,请检查."); } if (!target.exists()) { System.out.println("目标目录不存在,自动创建."); target.mkdirs(); } BufferedInputStream bisOut = new BufferedInputStream( new FileInputStream(outer)); BufferedInputStream bisIn = new BufferedInputStream( new FileInputStream(inner)); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(new File(target, outer.getName()))); byte[] temp = new byte[1024]; int len = 0; while ((len = bisOut.read(temp)) != -1) { bos.write(temp, 0, len); } bisOut.close(); while ((len = bisIn.read(temp)) != -1) { bos.write(temp, 0, len); } bos.close(); bisIn.close(); System.out.println("隐藏文件操作成功."); } } import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.util.Scanner; //定义抽取隐藏文件类 class ReCoverInfo { public static void main(String[] args) throws IOException { Scanner in = new Scanner(System.in); System.out.println("请输入隐藏文件所用表象文件路径:"); String outerStr = in.nextLine(); System.out.println("请输入隐藏文件操作后文件路径:"); String coveredStr = in.nextLine(); System.out.println("请输入隐藏文件提取后存储路径:"); String targetStr = in.nextLine(); File outer = new File(outerStr); File coveredFile = new File(coveredStr); File target = new File(targetStr); reCoverInfo(outer, coveredFile, target); } // 定义反向获取隐藏文件方法 private static void reCoverInfo(File outer, File coveredFile, File target) throws IOException { if (!outer.exists() || !coveredFile.exists()) { System.out.println("文件不存在,请检查."); } if (!target.exists()) { System.out.println("目标目录不存在,自动创建."); target.mkdirs(); } BufferedInputStream bisOut = new BufferedInputStream( new FileInputStream(outer)); BufferedInputStream bisCoveredFile = new BufferedInputStream( new FileInputStream(coveredFile)); target = new File(target, "提取出的隐藏文件_请自加后缀"); BufferedOutputStream bosReCoverInfo = new BufferedOutputStream( new FileOutputStream(target)); byte[] temp = new byte[1024]; int len = 0; while ((len = bisOut.read(temp)) != -1) { bisCoveredFile.read(temp); } while ((len = bisCoveredFile.read(temp)) != -1) { bosReCoverInfo.write(temp, 0, len); } bosReCoverInfo.close(); bisCoveredFile.close(); bisOut.close(); System.out.println("隐藏文件提取操作成功."); } } 总结:这个小代码说起来相当简单,其实就是在建立输出流对象是,将构造函数改为(File File,boolean true),即为追加模式. 在学习使用此代码时,发现追加模式写入另外文件信息时,并没有破坏第一个文件的数据结构,所以在window中能表现出表象文件的属性,也可以正常使用.但是同样的,在后面存储的完整的第二个文件的数据也得到了完美保存 ,将至截取出来重新封装便又还原了那个隐藏的文件.虽然代码没什么技术含量,不过记录下,算是一个小小的发现… 6.关于Map的keySet()方法返回的Set类型的探究. /* 需求：获取一个字符串中出现的字母及其出现次数。 分析：字符串每位上的字符进行遍历，然后将每位上的字符添加入定义好的一个Map集合。存储动作时加上判断，如果集合中不存在该键(字符作键)，添加该键值(字符,1),如果存在则值加1. 步骤: 1.键盘获取一个字符串对象. 2.定义一个Map,遍历字符串,将每一位上的字符当作键,存入Map集合。 3.存储都做加上判断，集合中没有，则值为1，存入。集合中有，则将已有值加一存入。 4.遍历Map集合并打印，达到要求格式。 */ import java.util.Map; import java.util.TreeMap; import java.util.HashMap; import java.util.Scanner; import java.util.Set; import java.util.TreeSet; class ApearNum { public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.println("请输入需要获取出现字母及其次数的字符串："); String str = in.nextLine(); TreeMap &lt;Character,Integer> strMap = new TreeMap&lt;>(); for(int i=0;i&lt;str.length();i++) //这里，突然想到增强for，适用于集合和数组，但不论从哪方面来说，String我都觉得他足够具有特殊性。 //for(Character str.charAt(i) : str) //所以这里,对增强for是否适用于String,进行了实验,事实证明,不行 //for(Character charI : str) { //Character temp =charI; Character temp=str.charAt(i);//遍历字符串.给自定义Map添加元素. if(strMap.get(temp)==null)//如果Map中不存在, { strMap.put(temp,1); } else { strMap.put(temp,strMap.get(temp)+1); } } System.out.println(strMap); //TreeSet &lt;Character> strSet = (TreeSet)strMap.keySet(); 这里，运行出现类型转换异常，可以得知，keySet()得到的键集合是与Map对应的类型. //TreeSet &lt;Character> strSet =(TreeSet)strMap.keySet(); 为什么这里,我已经将Map改成TreeMap还是类型转换异常? Set &lt;Character> strSet = strMap.keySet(); TreeSet strSet2 = (TreeSet)strSet; StringBuilder strSB = new StringBuilder(); for(Character key : strSet) { strSB.append("[").append(key+":").append(strMap.get(key)).append("] "); } System.out.println(strSB); } } 总结: 在上面的代码中,在我进行Map集合遍历的时候,有了这种想法,就是keySet返回的应到是key的一个Set集合,而众所周知,Map的具体子实现类的key是通过特定方式保证唯一的,就是Tree(二叉树)Hash(哈希表). 所以我就想这里得到的keySet()返回的Set集合是不是应该就是对应的TreeSet或者HashSet集合. 所以,代码中我用强制类型转换进行了试验,结果是悲剧的…他一个都不是. 所以从源代码中寻找答案. 发现,原来,TreeMap中的keySet()方法中,定义了一个静态的成员内部类,实现了一个叫SortedSet的接口(TreeSet也实现了该接口).并不是我想想的直接是TreeSet或者HashSet. 实际上TreeMap中和HashMap中该方法返回的分别都是静态的成员内部类,继承AbstractSet. 所以,这里我不得不感慨,Java多态思想运用的太太太出神入化了. 就像现实世界一句经典的话:不管黑猫白猫.抓到老鼠,都是好猫!]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>黑马程序员</tag>
        <tag>知识点</tag>
        <tag>思路</tag>
        <tag>java</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-异常]]></title>
    <url>%2F2014%2F01%2F03%2F%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[(感觉自己最近为了赶进度,很久没有总结回顾以前的知识,今天开始要深刻反思) 异常 1.1.异常概念：就是程序出现的不正常情况。1.2.异常体系:Throwable类 |–Error类 严重的问题，是处理不了的。要改正代码的。|–Exception类 非RuntimeException的，是需要处理的。编译期异常。 |–RuntimeException类 不需要处理的，是需要改代码的。运行期异常。 例如:Error:地震，海啸。Exception:感冒了，头疼。 1.3.java虚拟机的默认处理方法.把异常的类名，原因，位置等信息显示在控制台。一旦有异常发生，其后的代码不能继续执行。 1..4.异常的解决方案.A:try方式 基本格式： try{ 可能发生异常的代码; }catch(异常类名 变量名){ 异常的处理代码; }finally{ 释放资源的代码; } 注意：一旦有一次发生，就会立马执行catch里面的代码 。变形格式： try...catch try...catch...catch try...catch...catch...finally try...finally 注意: JDK7针对多个catch进行了优化： catch(异常1 | 异常2 | 异常3 … 变量){}这些异常必须是平级关系。和try…catch…catch的不同点是: JDK7的这种方案是必须平级关系，不能有子父关系。而try…catch…catch父亲放最后是可以的。B:抛出处理用throws关键字在方法上声明(抛出)。(这种方法比较消极,不推荐使用) 1.5.Exception和RuntimeException的区别.A: Exception 编译时期异常，必须处理的。如果在方法上，throws了该类型的异常，将来调用者必须处理。如果在方法内部，throw了该类型的异常，必须在方法上throws该异常。B:RuntimeException 运行时期异常，是不需要处理的。要改代码的。如果在方法上，throws了该类型的异常，不需要处理。如果在方法内部，throw了该类型的异常，方法上可以throws该异常，也可以不throws该异常。 1.6.关于异常我的总结throw:1.使用在方法内部,格式为:throw &lt;异常对象&gt;.(只能是单个对象)2.throw不可以单独使用,要么搭配throws,将异常抛出给调用方法者;要么搭配try-catch-finally处理掉该异常.throws:1.使用在方法声明上,在参数列表后与方法体前,格式为:throw &lt;异常类&gt;.(可以单个或者多个类,逗号分割)2.throws可以单独使用,将可能抛出的异常抛出给调用方法者处理.(如果是主方法上使用,即由jvm异常处理机制处理). try{}:try{}的大括号中,放入的为执行中可能会出现异常的代码.如果当中的代码在执行时出现异常,就会通过或人工定义(使用throw)或系统自动生成并抛出异常对象.注意:当try{}代码块中执行时出现异常,抛出异常对象,下面的代码就不会执行了.catch(){}:catch(){}的小括号中为参数,参数应为对应try{}抛出异常对象的异常类或其父类.其大括号中为针对此异常的处理代码.当try{}抛出异常,由catch(){}捕获并处理.这里因为对应的try{}可能抛出多种异常,可以一个try{}对应多个catch(){}.当然,()中对应的应为对应的每种异常类,而且遵从子类异常优先,父类异常殿后的顺序.注意:JDK7的新特性,可以在catch(){}的参数中同时对应多个异常类,用|分割. finally{}:finally{}的大括号中放入的代码,无论try{}是否抛出异常catch(){}是否执行,它都会执行.一般用于关闭资源操作.注意:有几个特殊情况1.如果在try{}和catch(){}中出现了System.exit(0)语句,那就没办法,不执行了.2.如果try{},catch(){}中出现了return语句,则finally{}中代码和return代码同时执行.3.如果2中finally{}中也出现了return语句,那么先前的return语句会被finally{}中的return语句覆盖执行. 我的测试代码: //代码体现 public static void main(String[] args) throws Exception{ new Test8().demoMethod();//调用方法中声明了异常,这里必须处理或者上抛.(这里我上抛,没处理) } //方法中的异常处理方式. public void demoMethod() throws Exception{//如果方法中可能抛出异常,而没有对应的try-catch处理,那么就可以用throws向调用者声明,方法中会出现异常,由调用者处理. try { /* * 运行可能会出现异常的代码. */ //if()的括号中为认为定义应该抛出某个异常的条件 if (true) { throw new Exception();//抛出某一异常对象. } } catch (Exception e) { /* * 对应捕获到的异常进行的处理. */ }finally{ /* * 必然会执行的代码.例如:关闭资源.删除临时文件. */ } }]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-集合补充(Map类)]]></title>
    <url>%2F2014%2F01%2F02%2F%E9%9B%86%E5%90%88%E8%A1%A5%E5%85%85(Map%E7%B1%BB)%2F</url>
    <content type="text"><![CDATA[1.Map类(Map集合中,以键值对的形式保存映射关系.) 1.1.分类:按照键的保证唯一方式不同,分为两大类: HashMap:通过键的hashCode()方法和equals()方法来保证唯一. 注意: HashMap和Hashtable的区别在于,HashMap中任何对象,包括null都可以作为键值而Hashtable中只有非null对象可以作为键值 TreeMap:通过键的compareTo()方法来保证唯一.注意: 这里实现比较,达到二叉树的方法有两种,一种是在集合中元素的对象中实现compareTo()方法.一种是在定义TreeMap时在参数列表中给定一个Comparator对象. 1.2.HashMap类 1.3.案例:统计字符串字符出现次数 我的代码 package demo; /* 需求：获取一个字符串中出现的字母及其出现次数。 分析：字符串每位上的字符进行遍历，然后将每位上的字符添加入定义好的一个Map集合。存储动作时加上判断，如果集合中不存在该键(字符作键)，添加该键值(字符,1),如果存在则值加1. 步骤: 1.键盘获取一个字符串对象. 2.定义一个Map,遍历字符串,将每一位上的字符当作键,存入Map集合。 3.存储都做加上判断，集合中没有，则值为1，存入。集合中有，则将已有值加一存入。 4.遍历Map集合并打印，达到要求格式。 */ import java.util.Map; import java.util.TreeMap; import java.util.HashMap; import java.util.Scanner; import java.util.Set; import java.util.TreeSet; class ApearNum { public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.println(&quot;请输入需要获取出现字母及其次数的字符串：&quot;); String str = in.nextLine(); TreeMap &lt;Character,Integer&gt; strMap = new TreeMap&lt;&gt;(); for(int i=0;i&lt;str.length();i++) //这里，突然想到增强for，适用于集合和数组，但不论从哪方面来说，String我都觉得他足够具有特殊性。 //for(Character str.charAt(i) : str) //所以这里,对增强for是否适用于String,进行了实验,事实证明,不行. //for(Character charI : str) { //Character temp =charI; Character temp=str.charAt(i); if(strMap.get(temp)==null) { strMap.put(temp,1); } else { strMap.put(temp,strMap.get(temp)+1); } } System.out.println(strMap); //TreeSet &lt;Character&gt; strSet = (TreeSet)strMap.keySet(); 这里，运行出现类型转换异常，可以得知，keySet()得到的键集合是与Map对应的类型. //TreeSet &lt;Character&gt; strSet =(TreeSet)strMap.keySet(); 为什么这里,我已经将Map改成TreeMap还是类型转换异常? //通过查看底层源码得知:虽然键集合的确符合TreeSet或者HashSet集合的特性,但他其实是SortedSet的一个子类,并不是想当然的是HashSet或者TreeSet. Set &lt;Character&gt; strSet = strMap.keySet(); StringBuilder strSB = new StringBuilder(); for(Character key : strSet) { strSB.append(&quot;[&quot;).append(key+&quot;:&quot;).append(strMap.get(key)).append(&quot;] &quot;); } System.out.println(strSB); } } 1.4.总结MapHashMap底层数据结构是哈希表。线程不安全，效率高。它依赖两个方法：hashCode()和equals()保证唯一性. 顺序： 首先判断hashCode()值是否相同。 同：继续走equals()，看返回值 如果true：就不添加到集合。 如果false：就添加到集合。 不同：就添加到集合。 Hashtable(注意,这里table为小写,因为Hashtable在早起jdk版本存在底层数据结构是哈希表。线程安全，效率低。它依赖两个方法：hashCode()和equals())保证唯一性.**顺序：首先判断hashCode()值是否相同。 同：继续走equals()，看返回值如果true：就不添加到集合。如果false：就添加到集合。 不同：就添加到集合。** TreeMap底层数据结构是二叉树。线程不安全，效率高。根据返回是否是0保证唯一性。 自然排序(元素具备比较性):实现Comparable接口 比较器排序(集合具备比较性)**:实现Comparator接口]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>教程</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-集合框架2]]></title>
    <url>%2F2013%2F12%2F28%2F%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B62%2F</url>
    <content type="text"><![CDATA[1.Set类1.1Set的特点：元素无序,唯一。注意：这里的顺序是指存储和取出顺序。 2.HashSet2.1.HashSet：不保证元素的迭代顺序。并且，不保证该顺序恒久不变。2.2.怎么保证元素唯一HashSet底层数据结构是哈希表。依赖两个方法：hashCode()和equals()顺序：首先，判断hashCode()值是否相同。相同：继续走equals()方法，根据其返回值：true：说明元素重复，不添加到集合。false：说明元素不重复，添加到集合。不同：直接添加到集合。 2.3.如何重写hashCode()和equals()方法hashCode():把对象的所有成员变量值相加即可。如果是基本类型，就加值。如果是引用类型，就加哈希值。equals():A:this==objB:!(obj instanceof Student) C:所有成员变量的值比较。基本类型用==,引用类型用equals()。 我的代码: public int hashCode(){ //根据自己的需求定义hashCode的算法. return name.hashCode()+age*17; } public void equals&lt;Object&gt;(Object obj){ if(this==obj){ return true; }else if(!(obj intstanceof Student)){ return false; }else{ return (obj.getName().equals(name) &amp;&amp; obj.getAge==age)?true:false; 2.4.案例HashSet存储字符串并遍历HashSet存储自定义对象并遍历针对自定义对象：需求：如果对象的成员都相同，就认为是同一个元素。 3.TreeSet3.1.TreeSet：根据构造方法的不用，选择使用自然排序或者比较器排序。 按照实际的需求，可以对元素进行排序。并且保证唯一。 3.2.如何保证排序： 底层结构是二叉树。按照树节点进行存储和取出。两种实现：A:自然排序(元素具备比较性)TreeSet的无参构造，要求对象所属的类实现Comparable接口。B:比较器排序(集合具备比较性)TreeSet的带参构造，要求构造方法接收一个实现了Comparator接口的对象。 唯一：根据返回值是否为0。 注意： 如果同时有两种方案，以比较器为主。 我的代码: //TreeSet底层是二叉树,所以是通过比较来comparaTo方法来判断元素的是否唯一. //对于需要存储进集合的元素,通过其自身的comparaTo方法来跟集合中已经存在的元素进行比较运算,返回值为int型数据,为0,则不加入集合,为负数,则反向加入,为正数则正向加入. //对于基本类型数据元素,因为其父类实现了Comparable接口,所以必然覆盖了comparaTo方法,可以不定义,直接调用compareTo进行比较. //对于自定义类,因为类中未定义comparaTo方法或者未实现Comparable接口,则需要自己在类中来实现ComparaTo接口,重写compareTo方法.方法中具体内容根据实际要求编写.或者在建立这个TreeSet时,就根据其构造函数传入一个自己定义的比较器. class Student implements Comparable{ public int compareTo(Student stu){ int num1 = this.name.length()-stu.name.length(); int num2 = this.name.compareTo(stu.name); int num3 = this.age-stu.age; return (num1==0&amp;&amp;num2==0)?num3(num1==0)?num2:num1; } } 3.3.案例TreeSet存储字符串并遍历TreeSet存储Integer并遍历TreeSet存储自定义对象并遍历 4.Collection体现的集合总结Collection|–List|–ArrayList底层数据结构是数组，查询快，增删慢线程不安全，效率高。|–LinkedList底层数据结构是链表，查询慢，增删快线程不安全，效率高。|–Vector底层数据结构是数组，查询快，增删慢线程安全，效率低。|–Set 唯一|–HashSet底层数据结构是哈希表。如何保证元素唯一性呢?依赖两个方法。hashCode()和equals()。以后都自动生成。|–TreeSet 底层数据结构是二叉树。 如何保证元素唯一性呢?如何保证元素排序呢?根据返回值是否是0，判断元素是否重复。排序有两种方案：元素具备比较性 实现Comparable接口集合具备比较性 实现Comparator接口 5.集合中的数据结构ArrayXxx:底层数据结构是数组。查询快，增删慢。LinkedXxx:底层数据结构是链表。查询慢，增删快。HashXxx:底层数据结构是哈希表。跟两个有关。hashCode()和equals()TreeXxx:底层数据结构是二叉树。两种排序方式。Comparable接口和Comparator接口 6.如何选择Collection集合元素是否唯一?唯一：Set元素是否排序?需要：TreeSet不需要：HashSet不知道是否排序，用HashSet。不唯一：List需要安全码?需要：Vector不需要：ArrayList和LinkedList查询多：ArrayList增删多；LinkedList不知道，用ArrayList。 7.Collections7.1.Collections是针对Collection集合操作的工具类。7.2.面试题Collection和Collections的区别: 一个是Collection,集合体系不断向上抽取,最终得到的该体系的顶层类,定义了所有集合的共性内容. 一个是Collections,是一个类似于Arrays的静态工厂,基本上都是静态方法,是一个工具类.对集合进行加工. 7.3功能 ———–android培训、java培训、java学习型技术博客、期待与您交流！ ———— **详情请查看：http://edu.csdn.net/**]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-集合框架1]]></title>
    <url>%2F2013%2F12%2F26%2F%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B61%2F</url>
    <content type="text"><![CDATA[1.集合1.1.集合概念java是一种面向对象语言，如果我们要针对多个对象进行操作，就必须对多个对象进行存储。而对多个元素进行存储，前面我们学习过数组，数组的弊端，长度固定。这样，数组将不能满足变化的要求。所以，java提供了集合供我们使用。 1.2.集合的特点：A:长度可以发生改变B:只能存储对象C:可以存储多种类型对象(一般存储的还是同一种) 1.3.集合和数组的区别A:长度问题数组固定集合可变B:存储元素问题数组可以是基本类型，也可以是引用类型。集合只能是引用类型。C:元素是否为同一类型数组元素类型一致。集合元素类型可以不一致。 1.4.集合体现的由来集合是存储多个元素的容器，但是，由于数据结构不同，java就提供了多种集合类。而这多种集合类有共性的功能，所以，通过不断的向上抽取，最终形成了集合体系结构。 1.5.数据结构：数据存储的方式Collection|–List|–ArrayList|–Vector|–LinkedList|–Set|–HashSet|–TreeSet 1.6.如何学习和使用一个继承体系学习顶层：因为顶层定义的是共性内容。使用底层：因为底层才是具体的实现。 2.Collection的功能2.1Collection的功能 2.2.迭代器的使用A:使用步骤a:通过集合对象获取迭代器对象。b:通过迭代器对象判断。c:通过迭代器对象获取。B:迭代器原理由于多种集合的数据结构不同，所以存储方式不同，所以，取出方式也不同。这个时候，我们就把判断和获取功能定义在了一个接口中，将来，遍历哪种集合的时候，只要该集合内部实现这个接口即可。 C:迭代器源码(自己的分析) 2.3.集合的常见使用步骤：A:创建集合对象B:创建元素对象C:把元素添加到集合中D:遍历集合a:通过集合对象获取迭代器对象。b:通过迭代器对象判断。c:通过迭代器对象获取。 2..4.Collection存储并遍历。 3.List的特有功能(掌握)3.1.List的特有功能 3.2.List的遍历方式A:Iterator迭代器B:ListIterator迭代器C:普通for 3.3.ListIterator迭代器A:是Iterator的子接口。B:有自己的特有功能，可以逆向遍历数据，但是需要先正向遍历。一般不用。 3.4.面试题：并发修改异常A:并发修改异常的产生原因用迭代器遍历集合，用集合去\操作集合。B:解决方案：a:使用集合操作。b:使用列表迭代器操作。]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-常用API应用(持续跟新)]]></title>
    <url>%2F2013%2F12%2F22%2F%E5%B8%B8%E7%94%A8API%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[常用API总结. String类 StringBuffer类 Integer类 System类 Arrays类 Date类 DateFormat类 Calendar类 Collection类 Collections类 Iterator类 List类 HashMap类 Map.Entry类(内部类) Stack类 File类 Class类 To be continue……]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
        <tag>知识点</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-Java基础语法收尾]]></title>
    <url>%2F2013%2F12%2F19%2FJava%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%94%B6%E5%B0%BE%2F</url>
    <content type="text"><![CDATA[1.Eclipse的使用(掌握)1.1安装 A:解压B:复制到指定的目录(不要有中文,和其他非法字符)1.2使用A:打开软件的界面B:新建一个项目(工程)C:在项目下的src(源码包)下建立包D:在包下建立类E:在类里边写代码F:编译源文件(代码写完保存的时候会自动生成class文件，在项目的bin目录下。)G:执行class文件(右键 – Run As – Java Application)H:结果显示在Console控制台上1.3如何汉化A:找到汉化的插件B:把eclipse_zh复制到D:\develop\eclipse\dropins目录下1.4如何显示行号在代码最左侧前面，右键- Show Line Numbers1.5如何修改字体A：java代码字体Window – Preferences – Appearance – Colors and Fonts – Java– Java Editor– 选择右边的Edit进行修改即可。B：其他字体Window – Preferences – Appearance – Colors and Fonts – Basic – …1.6如果不小心把界面给弄没了不要担心有复位操作。window – reset …1.7快捷键A:内容辅助键alt+/main方法：先写main然后alt+/最后Enter输出语句：先写syso然后alt+/最后EnterB:快捷键ctrl+shift+o 对使用了其他包中的类或者接口进行自动导入注意：如果只有一个包中有这个类，会自动导入。 如果多个包中有这个类，会弹出一个框供你选择。ctrl+shift+f 对代码进行格式化注意：有些时候，编译器失灵了。快捷键格式化不起作用了。解决：右键–source–format看源码：选中类：F3或者Ctrl+鼠标点击1.8帮助你生成代码找到source。A：生成构造方法B：生成get/set方法C：@Override注解。告诉你，该方法就是重写父类或者父接口的。1.9删除项目步骤：选中项目 – 右键delete …A:从工作台中删除B:从硬盘删除区别：就是在删除的时候，有一个选项你是否选择了。1.10：导入项目在项目所在位置的空白处右键 – Import – General – Existing …(最长的那个)–browse 选择你项目的所在位置 – 最后Finish即可。1.11断点调试(必须掌握)看程序的执行流程。以及变量的变化过程。A:如何加断点在你想看从哪里执行的程序的左边双击即可。(不要在注释上做)在哪里加?哪里不会加哪里。最好在每个方法的第一条语句上加。B:如何使用右键 – Debug Aa – Java Application弹出一个界面问你：是否打开调试界面。yes是否记住我的选择。选中框框即可C:查看哪里左边：程序运行到哪里了右边：变量的变化过程D:怎么继续F6 执行一行。E:去除断点方式1：在点击的那个地方再次点击方式2：在debug调试界面–BreakPoints – remove All… 2.Object类的方法(理解)2.1类层次结构的顶层类是所有类的根类，超类。 所有的类都直接或者间接的继承自Object类。 2.2Object类的方法：A:toString() public String toString():返回对象的字符串表示形式。 组成：包名…类名@哈希值的十六进制 B:equals() public boolean equals(Object obj): 默认比较的是对象的地址值是否相同。 一般，会重写该方法。按照自己ide需求进行比较。 2.3面试题：==和equals()的区别? ==: 比较基本类型：比较的是基本类型的值是否相同。 比较引用类型：比较的是引用类型的地址值是否相同。 equals(): 比较引用类型，默认比较的是引用类型的地址值是否相同。 如果类重写了该方法，那就得按照重写后的规则进行比较。 代码: /* * A:字符串一旦初始化就不可以被改变 * 注意：这里指的是字符串在常量池里面的值不能发生改变。而不是说字符串的引用不能变。 * * B:String s1 = new String(&quot;abc&quot;);String s2 = &quot;abc&quot;;有区别吗？ * 有。 * 第一种方式，其实在内存中有两个对象存在。 * 第二种方式，在内存中只有一个对象存在。 */ public class StringTest { public static void main(String[] args) { String s = &quot;hello&quot;; s += &quot;world&quot;; System.out.println(s); // helloworld } } 3.String类的equals方法源码解析 /* * 标准的学生类 */ public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; } /* * 分析： * 返回值类型：boolean * 参数列表：两个年龄,int age1,int age2 */ // public boolean compare(int age1,int age2) // { // return age1==age2; // } //而我们现在学生的是面向对象的思想，一般来说，我们以后传参就会传递对象作为参数。 //改进版 // public boolean compare(Student s1,Student s2) // { // return s1.age == s2.age; // } //用this代替一个对象 // public boolean compare(Student s) // { // /* // * this -- s1 // * s -- s2 // */ // return this.age == s.age; // } @Override public boolean equals(Object obj) { //为了提高代码效率 if(this==obj){ return true; } //为了提高程序的健壮性 //加一个判断：判断传递过来的对象是否是Student类型的。 //怎么判断? //格式：对象名 instanceof 类名 判断对象是否是该类的对象,返回boolean类型 if(!(obj instanceof Student)){ return false; } /* * this -- s1 * obj -- s2 */ Student s = (Student)obj; //重写equals一般就是为了比较某个类的多个对象的所有成员变量值是否相同 //如果成员变量是基本类型，就用==比较 //如果成员变量时引用类型,就用该变量对应的引用类型的equals（）方法 return this.age == s.age &amp;&amp; this.name.equals(s.name); } // @Override // public String toString(){ // return &quot;name:&quot;+name+&quot;,age:&quot;+age; // } } ———————–android培训、java培训、java学习型技术博客、期待与您交流！———————- 详情请查看：http://edu.csdn.net/]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>教程</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-Java面向对象4]]></title>
    <url>%2F2013%2F12%2F16%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A14%2F</url>
    <content type="text"><![CDATA[1.包(掌握)1.1包其实就是文件夹。用于区分相同的类名。 1.2格式：package 包名1.包名2…; 1.3带包的编译和运行(了解)A:手动建包 B:自动建包 2.导包(掌握)2.1用一个类，需要用该类的全路径名称。如果多个地方使用，就比较麻烦，所以java提供了导包操作。 2.2格式: import 包名1.包名2...类名; 下面这种属于把指定包下的类都导入。这种用法不推荐。我们应该用谁导谁。 import 包名1.包名2...*; 2.3package，import，class的顺序package – import – class 3.四种权限修饰符(掌握)推荐：成员变量private构造方法public成员方法public 4.不同修饰符修饰的内容(和内部类无关)注意，常见规则如下：以后，所有的类都用public修饰。并且，在一个java文件中，只写一个类。以后，所有的成员变量用private修饰。以后，所有的成员方法用public修饰。如果是抽象类或者接口：public abstract + …以后，所有的构造方法用public修饰。如果类是工具类或者单例类：构造用private修饰 5.内部类(了解)5.1把类定义在一个类的内部。5.2访问特点：A:内部类可以直接访问外部类成员，包括私有B:外部类要想访问内部类成员，必须创建对象。 5.3内部类分类：A:成员位置private 安全static 方便调用B:局部位置定义在方法中。局部内部类访问局部变量必须加final修饰。延迟生命周期。 5.4匿名内部类(掌握)A:是定义在局部位置的没有名字的内部类。**B:前提存在一个类，抽象类，或者接口。 C:格式** new 类或者接口名() { 重写方法; } 本质理解：其实这是一个继承类或者实现接口的匿名的子类对象。D:使用:当你看到方法的形式参数是接口或者抽象类的时候。]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
        <tag>知识点</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-Java面向对象3]]></title>
    <url>%2F2013%2F12%2F15%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13%2F</url>
    <content type="text"><![CDATA[1.多态(掌握)1.1对象在不同时刻表现出来的不同状态。 1.2多态的前提A:要有继承或者实现关系。B:要有方法的重写。(否则没有多态的必要)C:要有父类引用或者父接口引用指向子类对象。注意：多态有三种体现形式类多态;抽象类多态;接口多态 1.3多态中的成员特点：A:成员变量 编译看左边，运行看左边。(变量不存在重写) B:成员方法 编译看左边，运行看右边。 举例：孔子装爹。(穿老子衣服,说自己的话) 我的理解:(用模具来理解) 父类引用指向子类对象.这个是多态最常见的表现形式,可以这么想.父类,子类,都是一个模具.成员变量,就像是可在模具上的信息,成员方法就像是模具上各种大大小小的凹槽,用来填充料.当生成一个父类引用,就是生成了一个父类的模具;此时如果指向一个子类对象,就是用子类的模具先做一个产品出来,然后再放到父类上塞进去.这个时候,因为子类是继承父类的,父类的凹槽子类中肯定全有,而子类中还可能会多出更多凹槽,所以在子类产品塞上父类的模具的时候,对于那些子,父类都有的凹槽,子类产品是能塞进去的.没有的就只能暂且留在模具外面.而成员变量,就是文字,这样,拿的谁的模具,文字就是谁的.这样就是完整的解释了:父类引用,指向子类对象了.而在这个情况下,想调用子类特有的功能,就需要进行向下转型.想,我们本来就是用子类模具做出来的产品,虽然在塞到父类模具中是,那些子类特有凹槽做出来的部分暂且留在父类模具外面,但是如果这个时候我们再把它塞回子类模具,怎么样,是不是就又全能塞进去了.这就是向下转型,能够使用子类特有方法了. 1.4多态的弊端：父类(接口)引用不能使用子类特有功能。为了解决这个弊端，我们需要向下转型。Fu f = new Zi(); //向上转型Zi z = (Zi)f; //向下转型Zi z = new Zi(); 1.5多态的好处：可以提高代码的扩展性和可维护性。 2.抽象类(理解)2.1定义:如果多个类中存在相同的方法声明，而方法体不一样，我们就可以只提取方法声明。如果一个方法只有方法声明，没有方法体，那么这个方法必须用抽象修饰。而一个类中如果有抽象方法，这个类必须定义为抽象类。 2.2抽象类的特点A:抽象类和抽象方法必须使用abstract修饰B:抽象类不能被实例化C:抽象类有抽象方法，用于子类实例化使用D:如果一个类是抽象类，那么，继承它的子类要么是抽象类。要么重写所有抽象方法。 2.3抽象类的成员特点A:成员变量 可以变量，也可以是常量B:构造方法 有构造方法C:成员方法 可以是抽象方法，也可以是非抽象方法 2.4抽象类的几个小问题A:抽象类不能被实例化，为什么有构造?他的构造用于子类实例化使用。(Object类都有个空参构造)B:一个类没有抽象方法，为什么定义为抽象类?不想被实例化。C:abstract不能和哪些关键字共存。final:final修饰的方法不能被重写,final修饰的类不能被继承.private:私有方法在子类中无法访问,无法被复写.static:静态的方法在方法加载时就存在,抽象方法静态没有意义. 2.5案例： 老师案例 学生案例 /* 具体事务：基本班学员，就业班学员 共性：姓名，年龄，学习，睡觉 */ abstract class Student {//建立学生类,抽象类,有私有属性姓名,年龄.有抽象方法学习,有普通方法睡觉. private String name; private int age; Student(){} Student(String name,int age) { this.name=name; this.age=age; } abstract void study(); void sleep() { System.out.println("我是传智学员,我要睡觉."); } void show() { System.out.println("该学生叫:"+name+"\t该学生年龄为:"+age); } } class BaseStudent extends Student { BaseStudent(){} BaseStudent(String name,int age) { super(name,age); } void study() { System.out.println("基础班学员学习基础知识.JavaSE"); } } class AdvStudent extends Student { AdvStudent(){} AdvStudent(String name,int age) { super(name,age); } void study() { System.out.println("就业班学员学习高级知识.JavaEE"); } } class StudentTest_abstract { public static void main(String[] args) { /* Student b=new BaseStudent("张三",18); b.show(); b.sleep(); b.study(); System.out.println("----分--------割---------线---"); Student a=new AdvStudent("李四",20); a.show(); a.sleep(); a.study(); System.out.println("----分--------割---------线---"); System.out.println("----分--------割---------线---"); */ } } 3.接口(理解)3.1定义如果一个抽象类中的方法都是抽象的，这个时候，java就提供了一种更抽象的表示形式：接口。接口：interface实现：implements格式：interface 接口名{}class 类名 implements 接口名 {} 3.2接口的特点：A:接口不能被实例化。B:一个类如果实现了接口： 要么是抽象类。 要么实现接口中的所有方法。 3.3接口的成员特点：A:成员变量 只能是常量。默认修饰符 public static finalB:成员方法 只能是抽象方法。默认修饰符 public abstract推荐：永远手动给出修饰符。 3.4接口的思想特点：A:对外暴露的规则老师的原话,但是我对这个思想的理解有些模糊,后来想了想,对外暴露的规则,可以这么理解,接口就是描述一项功能,或者行为,当一个类需要这个功能,就通过实现这个接口.当然,功能的实体是需要这个类重新定义的.接口就像是让你了解需要这个功能,你得遵守那些规则.接口就是这个对外暴露的让你知道的规则,他没必要具有这个功能的主体.B:是功能的扩展C:降低耦合度(关联度) 耦合：类与类的关系 内聚：类自己完成某件事情的能力(独立度)高内聚，低耦合。D:接口可以多实现。(想想啊,反正接口都是抽象方法,不存在类中的同名方法指向不明确的问题.) 3.5类，接口的关系A:类与类继承关系,只能单继承，可以多层继承。B:类与接口实现关系，可以单实现，也可以多实现。还可以在继承一个类的同时实现多个接口。C:接口与接口继承关系，可以单继承，也可以多继承。 3.6抽象类和接口的关系3.7案例：运动员和教练的案例。 /* 乒乓球,篮球运动员,教练. 乒乓球球员教练都需要会英语,出国交流. 思路分析: 1.运动员,教练都是人,都有姓名,年龄--->抽象类,人. 2.篮球运动员,乒乓球运动员都是运动员--->父类,运动员. 3.篮球教练,乒乓球教练都是教练--->父类,教练. 4.出国交流会英语--->接口,会英语. */ class Person//运动员,教练都是人,都有姓名,年龄--->抽象类,人. { private String name; private int age; Person(){} Person(String name,int age) { this.name=name; this.age=age; } void show() { System.out.println(name+"\t"+age+"岁"); } } interface SpeakEnglish//出国交流会英语--->接口,会英语. { public abstract void speak(); } abstract class SportsMan extends Person//篮球运动员,乒乓球运动员都是运动员--->父类,运动员. { SportsMan(){} SportsMan(String name,int age) { super(name,age); } abstract void doSports(); } abstract class Coach extends Person//篮球教练,乒乓球教练都是教练--->父类,教练. { Coach(){} Coach(String name,int age) { super(name,age); } abstract void teach(); } class BasketballSportsman extends SportsMan { BasketballSportsman(){} BasketballSportsman(String name,int age) { super(name,age); } void doSports() { System.out.println("篮球运动员,练习打练球."); } } class PingpangSportsman extends SportsMan implements SpeakEnglish { PingpangSportsman(){} PingpangSportsman(String name,int age) { super(name,age); } void doSports() { System.out.println("乒乓球运动员,练习打乒乓球."); } public void speak() { System.out.println("乒乓球运动员精通英语."); } } class BasketballCoach extends Coach { BasketballCoach(){} BasketballCoach(String name,int age) { super(name,age); } void teach() { System.out.println("能够训练篮球运动员打篮球."); } } class PingpangCoach extends Coach implements SpeakEnglish { PingpangCoach(){} PingpangCoach(String name,int age) { super(name,age); } void teach() { System.out.println("能够训练乒乓球运动员打篮球."); } public void speak() { System.out.println("乒乓球教练精通英语."); } } class SportsmanTest { public static void main(String[] args) { BasketballSportsman a1=new BasketballSportsman("姚明",29); a1.show(); a1.doSports(); System.out.println("----------分割线-----------"); BasketballCoach a2=new BasketballCoach("姚明他老子",50); a2.show(); a2.teach(); System.out.println("----------分割线-----------"); PingpangSportsman a3=new PingpangSportsman("邓亚萍",30); a3.show(); a3.doSports(); a3.speak(); System.out.println("----------分割线-----------"); PingpangCoach a4=new PingpangCoach("邓亚萍他老子",49); a4.show(); a4.teach(); a4.speak(); } }]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
        <tag>知识点</tag>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-Java面向对象2]]></title>
    <url>%2F2013%2F12%2F13%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12%2F</url>
    <content type="text"><![CDATA[1. 如何使用API(掌握)A:找到文档，打开文档。 B:点击左上角的显示变成隐藏，然后点击索引 C:你应该知道你要找谁?比如要找Math类.所以，你就在那个输入框里面输入Math，然后回车，再回车。 D:看这个类的结构 java.lang 类 Math java.util 类 Scanner 如果是java.lang包下的类，是可以直接使用的。(Math) 否则，就需要导包才能使用。(Scanner) E:看看对这个类的说明。 F:看构造方法 名称：字段 –成员变量 – 属性。 a:有构造方法，那么，就通过构造方法创建对象使用。 b:没有构造方法，那么，这个类的成员一般都是静态。通过类名调用。 G:按照正常的操作使用方法。 左边：(返回值,及返回值类型,是否静态) 是否静态：如果静态修饰，那么可以通过类名调用。否则，就必须创建对象调用。 是否有明确返回值：如果是void类型，就直接调用即可。否则，就可以输出或者赋值。 右边：(方法名,参数类表) 看方法名：不要写错了。 看参数：看参数类型及个数。 2. 继承(掌握)2.1何为继承把多个类中的相同属性和行为进行抽取,封装到一个类中.然后再建立新的类时,不需要重头开始起定义,继承刚才定义的那个类即可. 2.2继承的优点提高了代码的复用性.同时,使得类与共性属性行为的偶联性降低了. 让类与类之间产生一个关系,是多态的前提. 2.3使用继承的时间A:当两个类之间存在了is a 的关系,就可以考虑使用继承.就是a类是b类的一种. B.不要为了获取一个功能而去使用继承,要根据程序的自然属性等判断. 2.4继承的特点Java只支持但继承,不支持多继承.否则,当多个父类中定义了同名方法,子类调用时出现调用不明确问题. Java支持多重(多层)继承. 2.5关键字super和thissuper是一个关键字,用来代表父亲的存储空间标识.(可以暂时理解为父类的引用.) super的使用方法和this基本一致. 成员变量:this.变量-本类;super.变量-父类; 构造方法:this(…)本类;super(…)父类 成员方法:this.方法名()本类;super(…)父类 2.6子父类中的成员变量的用法名称不同,直接找对的调用. 名称相同,子类对象在使用时: 先找子类局部范围,再找子类成员范围,最后找父类成员范围. 2.7子父类中的成员方法使用名称不同,直接调用名称正确的. 名称相同,子类对象在使用时,先找子类的方法,再找父类的方法. 方法重写:在子类中,如果存在和父类方法声明完全相同的方法,则是子类对父类该方法的重写.(方法声明包括:修饰符,返回值,函数名,参数列表) 注意事项: 父类中的私有方法,final方法不能被重写. 子类方法的访问权限必须大于父类该方法的反问权限. 静态方法只能重写静态方法(基本不出现,静态在详解) 2.8子父类中构造方法的使用子类的初始化过程,首先会去执行父类的初始化动作. 因为,默认给子类构造方法中加入了一条super().因为,子类继承父类,子类在初始化时,相当有可能会使用到父类的成员变量,这个时候就必须先将父类进行初始化. 如果父类没有无参构造方法(解决方法) 手动使用super调用父类存在的带参构造,来实现初始化.(推荐) 使用this调用本身的其他构造函数. 案例代码: /* 分析如下需求，写出你分析的类有哪些，以及功能。 最后写一个测试类，针对每个类的功能进行测试。 动物园里有很多种动物： 比如说，狗，猫等。 狗有姓名和年龄，猫也有姓名和年龄。 狗有跑步的方法，猫也有跑步的方法。而且都仅仅是跑步。 狗有吃饭的方法，猫也有吃饭的方法。只不过，狗吃骨头，猫吃鱼。 请用所学知识，对这个问题进行解决。 */ class Animal { private String name; private int age; Animal() { } Animal(String name, int age) { this.name = name; this.age = age; } void run() { System.out.println(name+"^^^^^^^^^^^^^^^^"+age+"岁了"); System.out.println("看他跑起来了~！"); } } class Cat extends Animal { Cat() { } Cat(String name, int age) { super(name, age); } void eat() { System.out.println("他是猫，他在吃鱼。"); } } class Dog extends Animal{ Dog(){} Dog(String name,int age){ super(name,age); } void eat(){ System.out.println("他是狗，他在吃骨头。"); } } public class Day08_HomeWork { public static void main(String[] args){ Cat c=new Cat("小花",3); c.run(); c.eat(); Dog d=new Dog("小明",4); d.run(); d.eat(); } } 3. 代码块执行顺序: 静态代码块à构造代码块à构造方法 (静态代码块只执行一次) 4. final关键字是一个关键字,可以用于修饰类,成员变量,成员方法. 特点: 它修饰的类不能被继承. 它修饰的成员变量就是一个常量. 它修饰的成员方法不能被其子类重写(覆盖).]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
        <tag>基础视频</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-Java面向对象1]]></title>
    <url>%2F2013%2F12%2F11%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11%2F</url>
    <content type="text"><![CDATA[1. Java中的参数传递问题。(理解内存图)基本类型：形式参数的改变对实际参数没有影响。 引用类型：形式参数的改变直接影响实际参数。 2. 面向对象(理解)2.1面向对象：是基于面向过程的一种思想。 面向过程：以函数为基础，关注实现过程。 面向对象：以对象为基础，关注实现结果。 2.2面向对象的思想特点：A:是一种更符合人们思考习惯的思想。 B:把复杂的事情简单化了。 C:把我们从执行者变成了指挥者。 举例：买电脑。洗衣，做饭。旅游。把大象装进冰箱。(代码体现了，去看看) 2.3事物是如何体现的?A:属性 有哪些特征 B:行为 有哪些功能 2.4类与对象的关系：(掌握)把事物转换成类： A:成员变量:定义在类中，方法外。 B:成员方法:和以前的区别是去掉static。 类：是相关的属性和行为的集合。是一个抽象的概念。 对象：是某种事物的具体存在，具体的表现形式。 举例： 类：学生 对象：张三 2.5案例： A:学生类 B:手机类 C:汽车类(内存图) 2.5如何使用呢?A:创建对象 格式： 类名 对象名 = new 类名(); B:使用成员变量和成员方法 对象名.成员变量 对象名.成员方法 3. 成员变量和局部变量的区别（理解）3.1定义位置的区别成员变量：类中，方法外 局部变量：方法中，方法声明中 3.2初始化值的区别成员变量：都有默认值 局部变量：没有初始化值，必须先赋值才能使用。 3.3存储位置的区别成员变量：堆内存中 局部变量：栈内存中 3.4生命周期的区别成员变量：随着对象的存在消失 局部变量：随着函数方法调用的开始与结束 4. 封装（理解）4.1隐藏实现细节，提供公共的访问方式。类，方法等其实都是封装的具体体现。 4.2private关键字4.2.1用于修饰成员变量，成员方法。 4.2.2被修饰的内容在其他类中无法访问的。 4.3常见应用类中所有的成员变量私有，只给出对应的set，get方法。 代码体现： class Day07_Student { private int age; private char sex; private String name; Day07_Student() {} Day07_Student(int age,char sex,String name) { this.age=age; this.sex=sex; this.name=name; } void setAge(int age) { this.age=age; } int getAge() { return age; } void setSex(char sex) { this.sex=sex; } char getSex() { return sex; } void setName(String name) { this.name=name; } String getName() { return name; } void show() { System.out.println("姓名为："+name+"\t年龄为："+age+"\t性别为："+sex); } } class Day07_StudentTest { public static void main(String[] args) { Day07_Student s1=new Day07_Student(25,'男',"高富帅\"); s1.show(); System.out.println("\n=========啦啦啦啦我是可爱的分隔符=====================\n"); Day07_Student s2=new Day07_Student(); s2.setAge(20); s2.setSex('女'); s2.setName("白富美"); System.out.println("姓名为："+s2.getName()+"年龄为："+s2.getAge()+"性别为："+s2.getSex()); System.out.println("\n=========啦啦啦啦我是可爱的分隔符=====================\n"); s2.show(); } } 5. 构造方法（掌握）5.1格式及特点格式： 访问权限修饰符 类名（参数）{} 反问权限修饰符：public ，private 特点： 方法名类名相同 没有返回值类型 没有具体的返回值 5.2注意事项5.2.1如果不给构造方法，jvm默认给一个无参构造方法。 5.2.2如果给出构造方法，那么jvm将不再提供无参构造方法。 这个时候，如果要使用无参构造方法，必须自己提供。（推荐永远手动给出无参构造方法） 6. this关键字（掌握）6.1是一个关键字，代表当前类的引用。简单：在方法中，那个对象调用方法，this就代表谁。 6.2应用场景解决局部变量隐藏成员变量 7. static关键字（理解）7.1是一个关键字。可以修饰成员变量的成员方法。 7.2静态的特点：随着类的加载而加载 优先于对象存在 被类的所有对象所共享 可以通过类名直接调用 7.3静态的注意事项在静态方法中是没有this关键字的 静态方法只能访问静态的成员变量和静态的成员方法 7.4静态的调用方法被对象调用 被类名直接调用 8. Math类的随机数（理解）类名调用静态方法。 包：java.lang 类：Math 方法：public static double random() 取1-100之间的一个随机整数 int x=Math.random()/*100+1;]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>教程</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-Java语言基础3]]></title>
    <url>%2F2013%2F12%2F09%2FJava%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%803%2F</url>
    <content type="text"><![CDATA[1. 函数(掌握)1.1函数的定义指一段可以执行的具有特定功能的代码，小程序。 1.2函数的格式修饰符：现阶段，我们只用publicstatic 返回值类型：就是函数这段代码执行最终的结果的数据类型。 函数名：函数名称，方便我们调用，符合标识符命名规则。 参数：形参类型，数据类型；形式参数，就是接收实际参数的变量；实际参数，就是实际参与操作的变量(常量)； 1.3函数的特点函数和函数之间是平级关系。不能再函数中定义函数。 运行特点：函数只有再被调用时才执行。 1.4案例有返回值：求两个数的最大值。求两个数的和。比较两个数是否相等。 无返回值(void)：九九乘法表。 代码案例： /* 1:请设计一个类Demo，这个类包含如下操作： A:求两个数的和。 B:判断两个数是否相等。 C:输出九九乘法表。 最后在测试类Test中进行测试。 2:成员变量和局部变量的区别?思考 一般数据我没有说什么类型，默认int类型。适用于我讲课。 */ import java.util.*; class Demo {//定义一个方法，对两个数求和，返回int型的两数和。 intgetSum(int a,int b) { returna+b; } //定义一个方法，判断两数是否相等，返回值类型为boolean。 booleanifSame(int a,int b) { return(a==b)?true:false; } //定义一个方法，得到两个数的最大值，并输出较大者。 intgetMax(int a,int b) { return(a>b)?a:b; } //定义一个无返回值类型的方法，输出打印九九乘法表 voidprintChenfabiao() { for(int i=1;i&lt;=9;i++) { for(int j=1;j&lt;=i;j++) { System.out.print(i+"*"+j+"="+i*j+"\t"); } System.out.println(); } } } class DemoTest { publicstatic void main(String[] args) { Scannerin=new Scanner(System.in); while(true) { Demos=new Demo(); System.out.println("请输入两个数来求和，并判断是否相等："); inta=in.nextInt(); intb=in.nextInt(); System.out.println("这两个数的和为："+s.getSum(a,b)); System.out.println("这两数是否相等？相等为true，不等为false："+s.ifSame(a,b)); System.out.println("这两个数较大的为："+getMax(a,b)); s.printChenfabiao(); } } } 1.5函数的调用有明确的返回值： 单独调用：一般没有意义。 输出调用：能打印出需要的结果，但如果函数的返回值需要拿来继续操作就完蛋了…… 赋值调用：推荐方式。 1.6重载函数举例： public static intsum(int a,int b){…} public static int sum(int a,int b,int c){…} public static int sum(float a,float b){…} 必须，函数名相同，参数类表不同（个数不同，类型不同） 2. 数组(掌握)2.1数组的定义存储同一种类型的多个元素的容器。 优势：数组中的元素会被自动从0开始编号，方便获取。那个编号就叫做索引。 格式： A:int[] arr = new int[3]; B:int arr[] = new int[3]; C:int[] arr = new int[]{1,2,3}; D:int[] arr = {1,2,3}; 推荐A和D。 2.2Java内存图：（用来辅助理解，最好能搞清楚） A:栈存储局部变量使用。使用完毕，立马消失。 B:堆所有new出来的都在堆里面。 a:每一个实体都有地址值 b:每一个实体内的内容都有默认值 整数： 0 浮点数：0.0 字符： ‘\u0000’ 布尔： false c:在垃圾回收器空闲的时候被回收。 C:方法区 D:本地方法区 E:寄存器 2.3数组的操作：数组的索引。arri 数组的长度。arr.length 数组名.length A:数组的遍历 for(int i=0;i&lt;arr.length,i++) { System.out.println(arr[i]); } B:数组获取最值(数组的排序，查找元素，二分法，冒泡法等) 二分法： /* 需求分析：查找元素是否在数组中。 步骤：（二分法，数组前提有序） 1.创建一个数组。 2.通过脚标最大，最小取中间值得到一个中间（可能偏左边）。 3.用需要查找元素与之比较，相等则输出脚标。不相等则取半再比。 4.如果出现 */ import java.util.*; class FindArry { static int FindArry(int key,int[] arr) { int min=0; int max=arr.length-1; int mid=(min+max)/2; while (arr[mid]!=key) { if (key>arr[mid]) { min=mid+1; } else { max=mid-1; } if (arr[max]&lt;key||arr[min]>key) //if(min>max) { return -1; } mid=(max+min)/2; } return mid;//这里我认为我的判断条件比下面的要更效率 } public static void main(String[] args) { int[] arr={2,4,34,65,234,266,278,3456,4657}; System.out.println(FindArry(65,arr)); } } 冒泡法： class GetMax {//定义一个数组。 publicstatic void main() { int[]arr=new int{1,3,4,5,2,32,4,5,2,45,6,3,322}; for(inti=0;i&lt;arr.length-1;i++)//冒泡法遍历数组排序 { for(intj=o;j&lt;=i;j++) { if(arr[j]>arr[j+1]) { int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } }//遍历排序后数组。 for(inti=0;i&lt;arr.length;i++) { System.out.print(arr[i]); } } } 2.4二维数组(理解)：格式： A:int[][] arr = new int[3][2]; B:int[][] arr = new int[3][]; C:int[][] arr = {{1,2,3},{4,5},{6,7,8,9}}; 遍历：(for循环遍历) for(int i=0,i&lt;arr.length,i++) { System.out.println(arr[i]); } 应用：遍历求和。 int sum=0; for(int i=1;i&lt;arr.length;i++) { sum+=arr[i]; } System.out.println(sum);]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
        <tag>教程</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-Java基础-知识点-记录汇总(end)]]></title>
    <url>%2F2013%2F12%2F06%2FJava%E5%9F%BA%E7%A1%80-%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%AE%B0%E5%BD%95%E6%B1%87%E6%80%BB(end)%2F</url>
    <content type="text"><![CDATA[Java基础练习-思维-纠错-记录汇总(持续跟新) (即使是最幼稚的知识点或思维也要仔细对待) (以后跟新到代码记录贴中) Note1.关于循环的条件判断思路场景： 在进行练习判断一个数是否为素数的过程中，遇到这样的情况：定义int型n，打算用for循环遍历n次，判断n在模2到n-1过程中是否都得0。若为素数，则只有模1和模其本身会得0。所以在写for循环时，当满足取模后等于0，还得继循环历直到循环结束后判断是否结果都为0，是才为素数。这样让我纠结很长时间。 分析： 在需要循环是，会遇到虽然需要循环的次数是确定的，但判断条件较难描述，需要完全循环n次后判断符合判断条件的循环是否为m。那么就可以借助这个m来进行辅助判断。 在上面的素数判断过程中，相当于m=n-2，条件为n%i==0(i是为确定循环次数定义的增量)。或者相当于m=2，条件为n%i!=0。 所以就可以用两个嵌套循环或者外层用选择内层循环来达到需要的目的。 代码： 思路初步代码： /* 题目：判断101-200之间有多少个素数，并输出所有素数。 */ class Prime{ //对这个数某1，和某自己同时为0，否则不是 public static void main(String[] args) { int sum=0; for (int n=101;n&lt;=200;n++)//判断素数 { int m=0; for (int i=1;i&lt;=n;i++) { if (n%i==0) { m++; } } switch (m) { case 2: sum++; if(sum%10==0)//若打印10个后换行继续打印 { System.out.println(n+&quot; &quot;); }else System.out.print(n+&quot; &quot;); } } System.out.println(&quot;共有&quot;+sum+&quot;个素数&quot;); } } 整理优化代码： //判断素数 private static boolean isPrime(int n) { boolean flag = true; if(n==1) flag = false; else { for(int i=2;i&lt;=Math.sqrt(n);i++) { if((n%i)==0 || n==1)//模1，模自身为0。 { flag = false; break; } else flag = true;//当前循环为真。但由于并且没有break，所以会继续直到循环结束，如果依然这样，就是代表所有的每次循环都为真。 } } return flag;//遍历结束了，依然为真。 }//这里的判断，是考虑特殊情况1。 ————————————————————————————————————————————————————————————————————————————— Note2.判断是否素的数循环次数问题问题描述： 判断是否素数在定义循环时，循环体的循环次数定义资料判断表达式为为i=2;i&lt;=Math.sqre(n);i++.为什么？ 分析： 循环中是来判断这个数能不能被拆分成两个整数数相乘。但是从1开始取模，当取值取到这个数的开方，和面如果出先取模等于0的情况就会跟前之前未出现取模等于0矛盾，所以是垃圾运算。 举例： 21=3/7—&gt;在之前判断出3之后，就不用判断之后的7/3了。极端情况就是假设这个数是x/(x+1)。当判断出x/(X+1)的时候，后面就开始重复之前的判断了。 代码： for(int i=2;i&lt;=Math.sqrt(n);i++) ———————————————————————————————————————————————————————————————————————————— Note3.转义字符的使用Java中的打印输出语句中，对某些字符赋予了特殊含义。所以可以通过\ 反斜杠来转变其后面字母或者符号在输出语句中的含义。 \n：换行 \t：制表符（Tab键） \b：退格（Backspace） \r: 回车（回到本行行首并替换第一个字符） 或者用反斜杠来让一个原本被Java赋予了特殊含义的字符成为普通字符打印出来。 \” \’ ( { [等。 ———————————————————————————————————————————————————————————————————————————— Note4.标号辅助嵌套循环指定循环控制循环嵌套中，可以事先给每层循环命名。这样，用标号可以辅助循环嵌套中的执行流程控制。 格式： a1：for() 或者 a2：while() 并在需要使用break或者continue时后面加上需要返回或跳出那层循环名。例如： break a1; continue a2; 注意：break和continue只能出现在switch和循环中。他们的区别是break跳出循环，continue只是提前结束本次循环进入下次循环。 ———————————————————————————————————————————————————————————————————————————— Note5.关于基本数据类型和引用数据类型参数传递问题基本类型：形式参数的改变对实际参数没有影响。 引用类型：形式参数的改变直接影响实际参数。 基本数据类型，在一个方法当中定义后，只要不在本方法中对这个定义了某种基本数据类型的变量改变他的实际参数(也就是赋值，无论是隐式的还是直接赋值语句赋值)即使在其他调用了他的方法函数中对他的实际变量进行了更改，那么他只要形式参数不改变，那么他的的实际参数也就是他值也就就不会变。 而引用数据类型，在一个方法中定义，虽然不在本方法中对这个对这个引用数据类型的变量，虽然在本类中他的实际参数不改变，但在某个调用了它的方法中对他的实际参数进行了更改，那么在这个定义此变量的函数中，他的实际参数也会随之改变,因为他们同样指向一个地址值，操作同一个地址的数据。 ———————————————————————————————————————————————————————————————————————————— Note6.关于成员变量和局部变量定义位置：局部变量定义在方法中或者方法声明中。成员变量定义在类中，方法外。存储位置：局部变量是存储在栈内存中的。成员变量是存储在对内存中建立对象是所开辟的空间中的。初始化值：局部变量是必须在定义后给其赋初始化值的才能使用。成员变量则在定义后由系统默认初始化，然后再由程序显示初始化。声明周期：局部变量是与方法的调用与结束同步存在的。而成员变量则是同对象的建立消失同步存在的。 ———————————————————————————————————————————————————————————————————————————— Note7.遇到循环不好建立标准循环格式或者函数来表达时的做法再碰到不好建立循环的时候，可以列出一定数量的实例，将规律实例化，书面化。然后再在列出的实例中总结规律，找出标准格式。 案例： /* 需求：小于8的整数。先倒序，然后每位数字加上5,在用和除10的余数代替该数字。最后将第一位最后一位互换。 请任意指定一个小雨8的整数，并将加密后结果打印。 思路： 用数组存储每位上的数字，并倒序。 每位数字进行加，取模操作，并更新数组中元素。 对数组中首，尾元素互换。 遍历数组元素输出。 */ import java.util.*; class ShuziJiami { public static void jiaMi(int num) {//用数组存储每位上的数字，并倒序。 int[] arr=new int[8];//定义一个数组。 //赋值 //arr[0] = number/10/10/10/10/10%10; //System.out.println(arr[0]); //arr[1] = number/10/10/10/10%10; //arr[2] = number/10/10/10%10; //arr[3] = number/10/10%10; //arr[4] = number/10%10; //arr[5] = number%10; //改进版 //定义一个索引从0开始 /* int index = 0; arr[index++] = number/10/10/10/10/10%10; //System.out.println(arr[0]); arr[index++] = number/10/10/10/10%10; arr[index++] = number/10/10/10%10; arr[index++] = number/10/10%10; arr[index++] = number/10%10; arr[index++] = number%10; */ /* //改进版 int index = 0; while(number&gt;0) { arr[index++] = number%10; //获取个位,获取十位... number/=10; //number值变化为除以10, */ /* 第一次： number=123456,index=0 arr[0]=6; index=1，number=12345 第二次： index=1，number=12345 arr[1] = 5; index=2，number=1234 ... arr[0] = 6 arr[1] = 5; arr[2] = 4 ... index = 6 number = 0 */ } //数组遍历 /* for(int x=0; x&lt;index; x++) { System.out.println(arr[x]); } */ int index=0; System.out.print(&quot;您输入的原始密码为：&quot;+num); while (num&gt;0) { arr[index++]=num%10; //arr[index]=num%10; //index+=1; num/=10; }//每位数字进行加，取模操作，并更新数组中元素。 for (int i=0;i&lt;index;i++) { arr[i]+=5; arr[i]%=10; }//对数组中首，尾元素互换。 arr[0]=arr[0]^arr[index-1]; arr[index-1]=arr[0]^arr[index-1]; arr[0]=arr[0]^arr[index-1]; System.out.print(&quot;\n加密后密码为：&quot;); for (int i=0;i&lt;index;i++)//遍历数组元素并输出。 { System.out.print(arr[i]); } } public static void main(String[] args) { Scanner in=new Scanner(System.in); while (true) { System.out.println(&quot;请输入原始小于八位密码：&quot;); int num=in.nextInt(); jiaMi(num); System.out.println(&quot;\n&quot;+&quot;是否继续？1：继续，2：退出&quot;); int x=in.nextInt(); if (x==1) continue; break; } } } 这条note果然重要，今天又遇到个问题，结果用直接寻找规律建立方法来做，很容易想错。后来干脆列出来一系列实例，立马解决。下面放代码： /* 题目：古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子对数为多少？ 分析：用直接寻找规律来建立函数或者循环等来解决这个问题相当容易把自己想死机。所以通过实例法。 思路： 1.列出前些天每天兔子的个数： 第1天：1, 第2天：1, 第3天：2, 第4天：3, 第5天：5, 第6天：8, 第7天：13, 第8天：21.... 2.这样，相当容易就能发现数列的规律，那就是第n天的兔子对数，为前两天之和。所以，想知道第n天的兔子的对数，只要从1,2,3。。。开始累加就可以了。 3.代码实现 */ import java.util.*; class Rabbit { static int getRabbit(int n) { if (n==1||n==2) return 1; return getRabbit(n-2)+getRabbit(n-1); } public static void main(String[] args) { Scanner in=new Scanner(System.in); while (true) { System.out.println(&quot;请输入想查询兔子对数的月份：&quot;); int n=in.nextInt(); System.out.println(n+&quot;兔子为&quot;+getRabbit(n)+&quot;对&quot;); System.out.println(&quot;是否继续查询，任意数字继续，1：退出。&quot;); int x=in.nextInt(); if (x==1) break; continue; } } } ———————————————————————————————————————————————————————————————————————————— Note8.匿名对象作为参数进行传递&amp;局部变量隐藏全局变量局部变量隐藏全局变量： 就是指在一个类中的一个方法中，如果方法中和类的成员变量都定义了一个同名的变量s。那么如果在这个方法中调用这个变量，如果不加this则默认操作的是这个局部变量s，想要访问成员变量的s，就必须在s前面加this.。 匿名对象作为参数进行传递： 这是想表达，匿名对象他随机建立的那个临时对象的地址值作为一个参数进行传递。 案例： /* 匿名对象：没有名字的对象。 应用场景： 1.当只对方法只进行依次调用。 2.匿名对象可以作为实际参数进行传递。 */ import java.util.*; class Phone { Phone() {} Phone(Phone s) { s =new Phone(); } void show(Phone s)//就是把地址值(他也是一种变量)作为参数 { System.out.println(s); } } class PhoneTest { public static void main(String[] args) { Scanner in=new Scanner(System.in); while (true) { Phone w=new Phone(); Phone w2=new Phone(w); w2.show(w2); w.show(w); new Phone().show(new Phone());//老师，这里两个new Phone()的匿名对象是同一个地址么？？？（不是） System.out.println(&quot;是否继续？人以数字继续，1：退出&quot;); int i=in.nextInt(); if (i==1) break; continue; } } } ———————————————————————————————————————————————————————————————————————————— Note9.关于成员变量和局部变量局部变量和成员变量的区别 1.定义位置：局部变量定义在方法中或者方法声明中。成员变量定义在类中，方法外。 2.存储位置：局部变量是存储在栈内存中的。成员变量是存储在对内存中建立对象是所开辟的空间中的。 3.初始化值：局部变量是必须在定义后给其赋初始化值的才能使用。成员变量则在定义后由系统默认初始化，然后再由程序显示初始化。 4.声明周期：局部变量是与方法的调用与结束同步存在的。而成员变量则是同对象的建立消失同步存在的。 ———————————————————————————————————————————————————————————————————————————— Note10.关于JAVA初期学习方法及遇到问题的处理首先不得不承认,我可能有洁癖,或者说是是所谓的强迫症.比如,受不了玩单机RPG漏掉哪怕1个NPC不跟他对话而丢掉可能出现的隐藏剧情,受不了身边东西杂乱无章,受不了早上起床某个流程没做.所以,这个习惯在学习中,经常然我无所适从. 尤其在学习Java的过程中,Java本身就是一门在思维模式的要求上远远超过语言格式的语言(我是这么认为的),所以在学习过程中,尤其是面对零基础的入门者,初期必然遇到一大堆当时基本不太能完全理解透彻的问题.有时候,有原则的暂时忽略(有原则的,暂时性的)这些问题,虽然知道这样,自己的心里会有种心中打了疙瘩的感觉,但是,你没有选择.既然你推倒不了Java,就先让Java推倒你吧,你要记得,总有一天,我们会把Java反推倒,进行逆袭100遍啊100遍…… 所以,真心给跟我一样,完美癖的童鞋们,我们战略妥协吧,记得日后100遍啊100遍就行^v^. 而且,说实话,有些问题,在没有完全学好Java的基础知识理解起来的确比较费劲.日后会逐渐了解的… 此致 敬礼(Java,请记住我日后的100遍啊100遍~~~~) ———————————————————————————————————————————————————————————————————————————— Note11.关于多态的理解,用法等总结之前的我自己的理解. 父类引用指向子类对象.这个是多态最常见的表现形式,可以这么想.父类,子类,都是一个模具.成员变量,就像是可在模具上的信息,成员方法就像是模具上各种大大小小的凹槽,用来填充料.当生成一个父类引用,就是生成了一个父类的模具;此时如果指向一个子类对象,就是用子类的模具先做一个产品出来,然后再放到父类上塞进去.这个时候,因为子类是继承父类的,父类的凹槽子类中肯定全有,而子类中还可能会多出更多凹槽,所以在子类产品塞上父类的模具的时候,对于那些子,父类都有的凹槽,子类产品是能塞进去的.没有的就只能暂且留在模具外面.而成员变量,就是文字,这样,拿的谁的模具,文字就是谁的.这样就是完整的解释了:父类引用,指向子类对象了.而在这个情况下,想调用子类特有的功能,就需要进行向下转型.想,我们本来就是用子类模具做出来的产品,虽然在塞到父类模具中是,那些子类特有凹槽做出来的部分暂且留在父类模具外面,但是如果这个时候我们再把它塞回子类模具,怎么样,是不是就又全能塞进去了.这就是向下转型,能够使用子类特有方法了. 大神思维帮助理解.(借鉴了黑马论坛某贴) 多态的根本原因在于父类引用变量在编译时拥有一个类型，叫编译时类型，在执行时有另一个类型，叫运行时类型。而这两个类型可以相同，也可以不同(不相同:比如父类引用指向子类对象.)。一个引用变量的编译时类型是赋值表达式左边的类型，运行时类型是赋值表达式右边的类型。 举个例子：Animal ref = new Dog(….)ref的编译时类型是Animal。所以代码中不能调用Animal中没有的方法。假设Dog复写了Animal中的某个方法。ref的运行时类型是Dog，运行的就是Dog复写后的方法。那为什么super关键字可以调用父类“未被复写的”方法呢？我觉得复写这个词很具有误导性。内存中复写前和复写后的方法都存在，不是你死我活的关系，应该叫“多态”方法更准确些。super调用了父类内存中的方法，表现给我们看的效果就是“复写前”。this调用了子类内存中的方法，表现给我们看的效果就是“复写后”。自始至终你的每一行代码都载入了内存，没有被JVM吃掉，只是JVM它选择性的挑了一个给你看。一句话总结，复写没有改变任何东西，只是多了一个选择而已。只不过因为一般只能向上转换，也就是运行时类型是编译时类型的子类，看上去引用变量调用的只能是子类的“复写后”方法，“被复写”的方法“似乎”被消灭了。其实它还顽强滴活在父类的内存里，一个super就能调出来. 关于子父类,复写方法,细究. 案例: class Fu { static int number=20; int num=2000; void method() { System.out.println(&quot;Fu\t&quot;+num); } void show() { System.out.println(&quot;Fu\t&quot;+number); } } class Zi extends Fu { static int number=10; int num=1000; void method() { System.out.println(&quot;Zi\t&quot;+num); } void show() { System.out.println(&quot;Zi\t&quot;+number); } } class Test { public static void main(String[] args) { Fu test=new Zi(); test.show(); test.method(); System.out.println(test.number); System.out.println(test.num); } } //---------------------------------------- /* Zi 10 Zi 1000 20 2000 请按任意键继续. . . */ 这个结果很好的可以给我拿来思考.很明显,这样建立的对象test我是拿父类的引用,建立的子类对象.他的成员变量,不管是不是静态,都是父类的值.(后面两行的结果:20,2000) 而看到方法,输出的是子类复写了的内容,这里,我起初有点迷糊.因为子父类具有同名变量.刚开始以为前两行应该输出:Zi 20,Zi 2000.很明显,在复写过程中,方法中调用变量还是遵循了就近原则,所以子类复写父类方法,是单独将子类的方法在子类中调用操作,将操作完成后的子类方法给了对象.而不是我之前以为的Zi类复写方法中调用的是Fu类的num和number. 总结就是:多态中涉及到的跨类调用,除非用super,否则都是本类中调用,是谁的方法,就在谁的类中找变量,当然,子类如果在本类中找不到某些变量,可以去父类中再找一下.———————————————————————————————————————————————————————————————————————————— Note12.关于继承与实现(is a,like a很好么?为什么大家都拿这个用?) 其实我也不知道谁发明的这个:is alike a我觉得反而让新手理解更难…我就是其中一个…..根本没必要拽英文啊.继承,就是继承一个父类,把子类看作父类一样的事物,子类是父类范畴的一员,就说子类继承了这个父类.实现,就是实现一个接口,把接口看作一个描述,一个类是符合了接口的描述的一种事物,就说这个类实现了这个接口.打个比方,门口贴的招聘启示,要招一个20岁以下,男,170cm以上的保安.可以把这个招聘启事当作一个接口,来这里应聘的是不是都是实现了这个招聘启事的要求的人?就说来的都是实现了这个招聘启事接口的类.那好,等你应聘进去了,成为了一个保安,是不是就是成为了保安这个群体的一员?这就理解为你这继承了保安这个类. 我暂且这么理解,期待以后跟新思维. ———————————————————————————————————————————————————————————————————————————— Note13.关于重写hashCode方法.在HashSet,HashMap,Hashtable中,都是用到了hashCode()方法,根据自己的需求,将hashCode方法进行重写,来保证我们集合中元素的唯一性. 这里,就出现了个问题.我重写了hashCode方法,然后将某些同类型对象存储进入集合中.随后,其中某个对象的成员属性进行了更改…然后就诡异了…如果想删除该元素,就没把法了通过remove来删除了. { public static void main(String[] args) { Collection&lt;Student&gt; col = new HashSet&lt;&gt;(); Student s1 = new Student(&quot;gll1&quot;,123); Student s2 = new Student(&quot;gll2&quot;,223); Student s3 = new Student(&quot;gll3&quot;,323); col.add(s1); col.add(s2); col.add(s3); s1.age = 323; for( Student temp : col){ System.out.println(temp); } System.out.println(col.remove(s1)); for( Student temp : col){ System.out.println(temp); } } } 并且,再次添加该元素,结果无法保其唯一行了.这就是所谓的内存溢出…所以,重写了hashCode方法后,集合中对象的成员属性最好别更改的!!! ———————————————————————————————————————————————————————————————————————————— Note14.网络编程里容易忽略还找不到的小问题 如上图的代码,网络编程中,最容易忽略的应该就是字符流是用到了readLine方法,而没有仔细考虑到读取后,会减少一个换行符的问题. 如果在上面的代码里面,没有放newLine()那么就会造成两边都阻塞在readLine代码那里了… 还有需要注意的就是,流的关闭问题.Socket的流只有一次获得,关闭的机会.所以,一个套接字,不能实现多次从中获得输入,输出流的操作. ———————————————————————————————————————————————————————————————————————————— ———————–android培训、java培训、java学习型技术博客、期待与您交流！———————- 详情请查看：http://edu.csdn.net/]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>笔记</tag>
        <tag>知识点</tag>
        <tag>纠错</tag>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序猿之葵花宝典-转载至陆其明的bolg]]></title>
    <url>%2F2013%2F12%2F06%2F%E7%A8%8B%E5%BA%8F%E7%8C%BF%E4%B9%8B%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8-%E8%BD%AC%E8%BD%BD%E8%87%B3%E9%99%86%E5%85%B6%E6%98%8E%E7%9A%84bolg%2F</url>
    <content type="text"><![CDATA[最近，我大量阅读了Steve Yegge的文章。其中有一篇叫“Practicing Programming”（练习编程），写成于2005年，读后令我惊讶不已： 与你所相信的恰恰相反，单纯地每天埋头于工作并不能算是真正意义上的锻炼——参加会议并不能锻炼你的人际交往能力；回复邮件并不能提高你的打字水平。你必须定期留出时间，集中锻炼，这样才能把事情做得更好。 我认识很多杰出的程序员——这是在亚马逊工作最好的额外“福利”之一。如果仔细观察他们，你会发现他们时时都在锻炼。他们已经很优秀了，但他们仍然不忘锻炼。他们锻炼的方法林林总总，而我在这篇文章中只会介绍其中的几种。 据我了解，这些杰出程序员之所以如此成功，就是因为他们一直在锻炼。完美的身材要靠定期的锻炼才能获得，而且必须坚持锻炼才能保持，否则身材就会走形。对于编程和软件工程来说，道理是一样的。 这是一个重要的区别——我每天都开车去上班，但我的驾驶水平远远不如专业车手；类似的情况，天天编程可能并不足以使你成为一名专业的程序员。那么，什么才能把一个普通人变成一名专业车手或者专业程序员呢？你需要锻炼什么呢？ 答案就在《科学美国人》的一篇名为“The Expert Mind”（专家思维）的文章里： 爱立信提出，重要的并不是经验本身，而是“努力的学习”，也就是要不断地挑战自身能力之外的东西。一些狂热的爱好者花费了大量的时间去下棋、打高尔夫球或者玩乐器，但他们可能始终停留在业余水平上，而一个训练有素的学生却可以在相对较短的时间里超越他们，原因就在这里。值得注意的是，在提高水平方面，花费在下棋上的大量时间（即使参加各种比赛）似乎还是比不过专门的训练来得更为有效。训练的主要价值在于发现弱点，并有针对性地进行提高。 “努力的学习”意味着，要常常去处理那些刚好在你能力极限上的问题，也就是那些对你来说有很大可能失败的事情。如果不经历一些失败的话，你可能就不会成长。你必须不断地挑战自我，超越自己的极限。 那样的挑战有时会在工作中碰到，但也未必。将锻炼从职业工作中分离出来，这在编程领域常被人称为“编码套路”（Code Kata）。 Code Kata的概念是由David Thomas提出的，他是《程序员修炼之道：从小工到专家》的作者之一。这个概念主要指的是，针对某一种特定技术或技能进行重复性的练习，从而将其熟练掌握。 ——译者注 所谓套路，就是一系列的招式。这个概念借鉴于武术。 如果你想要看一些编码套路的例子（也就是努力学习和磨练编程技能的方法），SteveYegge的文章里倒是提出了一些不错的建议。他把它们称作为“实践演练”： 1.写一份自己的简历。把自己所有的相关技能都罗列出来，然后把那些在100年后还用得到的标出来。给每个技能打分，满分为10分。 2.罗列出你所景仰的程序员。尽量包括那些与你一起工作的人，因为你会在工作中从他们身上获取一些技能。记录下他们身上的1 ~ 2个闪光点，也就是你希望自己有所提高的方面。 3.去查看维基百科（Wikipedia.Org）上“计算机科学”栏目，找到“计算机科学的卓越先驱”这部分，从这个列表中挑选一个人，阅读他的事迹，并且在阅读时打开任何你感兴趣的链接。 4.花20分钟通读别人的代码。读出色的代码和读糟糕的代码都是有益的，两者都要读，轮流切换。如果你无法感觉出它们之间的区别，可以求助于一位你尊敬的程序员，让他给你展示一下什么是出色的代码、什么是糟糕的代码。把你读过的代码给别人也看看，问问他们的看法。 5.罗列出你最喜欢的10个编程工具——那些你觉得你用得最多、非有不行的工具。随机挑选其中的一个工具，花一个小时去阅读它的文档。在这一个小时里，努力去学习这个工具的某个你不曾意识到的新功能，或者发现某种新的使用方法。 6.想一想，除了编程之外你最擅长什么事情？再想一想，你是通过怎样的锻炼才变得如此熟练和专业的？这对于你的编程工作又有什么启发呢？（怎么把这些经验应用到编程方面？） 7.拿出一叠简历，并和一组面试官在同一个房间里待上一个小时。确保每份简历都至少被3个面试官看过，并且要给出1 ~ 3分的评分。针对那些不同面试官评判大相径庭的简历展开讨论。 8.参与一个电话面试。事后写下你的反馈，抛出你的观点，然后与主持电话面试的人聊一聊，看看你们是否达成了一致的结论。 9.进行一次技术面试，并且被面试的人应该是某个你不太了解的领域里的专家。让他假定听众在该领域里一无所知，因此请他从最基础的讲起。努力去理解他所说的，必要时问一些问题。 10.有机会参与别人的技术面试。期间，你只是认真地听、认真地学。在应聘者努力解决技术问题的同时，你也要在自己脑子里尝试解决这些问题。 11.找到一个能和你交换实际问题的人，每隔一周，相互交流编程问题。花10 ~ 15分钟来尝试解决这些问题，再用10 ~ 15分钟进行讨论（无论能否解决）。 12.当你听到任何你一时之间也无法解决的面试问题时，赶紧回到你的座位上，把这个问题用电子邮件发给自己，以留作日后的提醒。在那一周里找出点时间，用自己最喜欢的编程语言来解决它。 我之所以喜欢Steve开出的这个清单，是因为它看上去很全面。有些程序员一想到“锻炼”，总认为就是一些编码上的难题。但在我看来，编程更在于人，而不是代码。因此，通过解决世上所有的、并且晦涩的编程面试题目，在提高你的个人能力方面，这种方法是有局限的。 关于“努力的学习”，我也很喜欢Peter Norvig在“Teach Yourself Programming in TenYears”（花10年时间自学编程）一文中提出的诸多建议： 1．与别的程序员交流。读别人的代码。这比任何书籍或培训课程都更重要。 2．动手写程序！最好的学习方法就是边做边学。 3．在本科或研究生的课程中学习编程课程。 4．找一些项目来做，并且需要与其他程序员形成团队来合作。在项目的进行过程中，学会辨别最出色的程序员以及最糟糕的程序员。 5．在项目中跟随别的程序员一起工作，了解如何维护那些不是你写的代码，并且学习如何写出利于他人维护的代码。 6．学习多种不同的编程语言，特别是那些与你现在所熟悉的语言有着不同的世界观和编程模型的。 7．了解硬件对软件的影响。知道你的电脑执行一条指令需要多少时间，从内存中取出一个字（在有缓存或没缓存的情况下）需要多少时间，在以太网（或者因特网）上传输数据需要多少时间，从磁盘中读取连续的数据或者在磁盘上跳转到另一个位置需要多少时间，等等。 你还可以从Dave Thomas的21种实用的编码套路中获取灵感（CodeKata.com），或者你更愿意加入一个你家当地的“编程武馆”（CodingDojo.org）。 对于“努力的学习”，我无法像Steve，Peter或者Dave那样提供一个长长的建议列表。我远不如他们有耐心。实际上，在我看来，“编程套路”只需两个招式： 写博客。我在2004年初创办了CodingHorror.com博客，作为我自己努力学习的一种形式。它在一开始很不起眼，到后来成为我职业生涯中做过的最重要的一件事。所以，你也应该写博客。最后“闻达于天下”的人，往往就是那些能够有效书写和沟通的人。他们的声音最响亮，是他们在制定游戏规则，并且引领世界的潮流。 积极参与著名的开源项目。所有的高谈阔论听起来都很好，但是，你是一个大话王还是一名实干家呢？别光说不练，这个非常重要，因为人们会用你的行动来衡量你，而不是你的言论。努力在公众面前留下些实实在在有用的东西吧，到时候你就可以说，“我在那个项目中出过力。” 当你能编写精彩的代码、并且能用精彩的言辞向世人解释那些代码时，到那时候，我会觉得你已经掌握了最牛的编码套路！ 写的很好，看完很有感触]]></content>
      <categories>
        <category>转载经典</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>教程</tag>
        <tag>编程语言</tag>
        <tag>锻炼</tag>
        <tag>职业生涯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-Java语言基础2]]></title>
    <url>%2F2013%2F12%2F05%2FJava%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%802%2F</url>
    <content type="text"><![CDATA[1. 运算符(部分2)1.1. 关系运算符==,&lt;=,&gt;=,!=,&lt;,&gt; 特点:关系运算符返回布尔型结果. 注意:==与=的区别. 1.2. 逻辑运算符&amp;,|,^,&amp;&amp;,!,||, &amp;:有false则false. |:有true则true. ^:不同则true,相同则false. !:true变false,false便true. &amp;,|,^：运算两个值；!：只运算一个值。 &amp;&amp;和&amp;的区别是：如果左边有false了，右边将不再执行。 ||和|的区别是：如果左边有true了，右边将不再执行。 (开发中我们常用&amp;&amp;,||,!，因为提高了效率。) 1.3. 位运算符(了解)&gt;&gt;:右移。右移变小，高位补零，低位舍弃。 &lt;&lt;:左移。低位补零。高位舍弃，低位补零。（关于数据准确，&lt;&lt;1时基数大于半值？） &gt;&gt;&gt;:无符号右移。 ^:亦或。 1.4. 三元运算符(条件运算符)格式：条件表达式?表达式1:表达式2 执行流程： 根据条件表达式返回的boolean值来决定。 返回true则表达式1作为结果。 返回false则表达式2作为结果。 1.5.运算符优先级——(重点)运算符的优先级决定了表达式的执行顺序，表达式的运算通常是按照运算符的优先级由高到低依次执行的。 2.if语句2.1. 用于做判断时使用常见对某个范围进行判断，或者对几个变量进行判断，或者boolean表达式的判断。 2.2.格式：### if(条件表达式1) { 语句体1; }else if(条件表达式2) { 语句体2; }else { 语句体else; } 执行流程： 是否条件表达式1成立，是，执行语句体1并结束if语句。否，则判断条件表达式2,是否成立，是，执行语句体2并结束if语句。否，则执行语句体else并结束if语句。 注意： 所有的if()都是一个整体，都是if判断语句的部分，执行了一个if中语句体就不会再执行其他的了。 大括号里的语句体如果是一条语句，可以省了大括号，建议不省略。 在使用时，会根据条件适当省略else if或者省略else或者都省略,推荐不。 大括号和分号一般不同时出现。 2.3.案例A:根据键盘录入的成绩，判断等级。 B:根据键盘录入的月份，输出该月份对应的季节。 3.switch语句3.1.用于做选择时使用。一般用于几个常量的判断。switch会把几个常量先直接加载到内存，在判断时，效率高(相比较if)。 所以，针对几个常量的判断，一般用switch语句。 3.2.switch语句的格式。3.2.1.针对格式的理解 switch：表示这里使用的时switch语句，后面跟的是选项的表达式。 switch(表达式) { case值1: 语句体1; break; case值2: 语句体2; break; case值3: 语句体3; break; … default: 语句体default; break; } 表达式：byte,short,int,char JDK5以后可以是枚举。JDK7以后可以是字符串。 case： 表示这里就是选项的值，他后面的值将来和表达式的值进行匹配。 case后面的值(可以叫标签，是不可以重复的)。 break： 表示执行到这条语句体时，就会跳出swithc语句。 default： 当所有的case和表达式都不匹配时，就会读取default的内容。 相当于if语句的else，某些情况可以省，建议不省略。 3.2.2.执行流程 进入switch语句后，会读取表达式的值，再去对应匹配case值。 找到了(若没找到则匹配default)，则执行对应的语句体，然后忽略case行，按照上下顺序执行直到break或者结束。 3.2.3.注意事项 A:default 可以省略，但不建议，因为有它能帮助明确思路。而且default的位置是没有要求的，跟所有case都没有优先级。 B:break 在最后一行时理论是可以省略的，但不建议，可以帮助明确思路。case里面的break省略需要判断具体情况，可能会影响选择结果。 C:关于结束switch语句 只有当执行到break语句体或者执行到switch语句最后一行时结束。 3.3.案例A:根据键盘录入的日期(1-7)，输出对应的星期日期。 B:根据键盘录入的月份，输出该月的季节。 4.Scanner的使用4.1.Scanner时JDK5以后设计出用来接受键盘录入数据使用的。4.2.目前我们要通过键盘录入int类型，只能使用这种方法。A:导包 import java.util*; B:创建对象，封装键盘录入 Scanner in=new Scanner(System.in); C:调用方法，获取键盘录入的数据 int XXX=in.nextInt(); 5.for语句5.1.需要循环时，当明确需要循环的次数时，可以使用for语句。5.2.for语句结构： for(初始化条件;判断条件;控制条件) { 循环语句体; } 5.3.注意事项 A:for循环用于能有明确循环次数的循环。 B:语句中如果用来确定循环次数的增量定义在语句内，该变量在循环结束后失效。 C:先执行初始化条件，执行判断条件，根据返回值选择是否执行循环语句体，并判断是否结束循环。 6.while循环语句6.1.需要循环时，二循环的次数不确定，可以使用while循环。6.2.while语句格式：while在前： 初始化条件； while(判断条件) { 循环语句体; 控制条件; } while在后： 初始化条件； do { 循环语句体; 控制条件; }while (判断条件) 6.3.注意事项A:while循环中需要定义能够是循环结束的条件判断语句，即要定义break；否则容易造成死循环。 B:while在前与while在后的区别在于在前先判断，在决定是否执行循环语句体。而在后则先执行一遍循环语句体，在进行判断。就是在后循环语句体至少执行一次。 C:最简单的定义无限循环的方式就是while(true){}。 D:while在前时，先执行初始化条件，执行判断条件，根据返回值选择是否执行循环语句体，并判断是否结束循环。while在后时，先执行初始化条件，然后执行循环体和判断条件，然后根据返回只选择是否结束循环。 7.循环嵌套案例：正三角，倒三角，九九乘法表。 7.1.循环嵌套中，可以事先给每层循环命名。格式： a1：for() 或者 a2：while() 并在需要使用break或者continue时后面加上需要返回或跳出那层循环名。例如： break a1; continue a2; 7.2.注意break和continue只能出现在switch和循环中。他们的区别是break跳出循环，continue只是提前结束本次循环进入下次循环。 8.各种应用场景 变量：发现有一个数据是变化的时候，就要使用变量。 if语句：一个范围的判断，boolean类型的表达式的判断，几个数据的判断。 switch语句：几个数据的判断。一般这种情况优先选switch。 for语句：循环次数或者范围确定。(水仙花) while语句：循环次数或者范围不确定。(珠峰)]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
        <tag>教程</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-JAVA基础语法1]]></title>
    <url>%2F2013%2F12%2F04%2FJAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%951%2F</url>
    <content type="text"><![CDATA[1.关键字1.1.定义：被JAVA语言赋予了特殊意义的单词。1.2.特点：JAVA语言中的所有关键字都是小写。1.3.注意事项：goto和const作为保留字存在。（在JDK中的新版本可能会被提升为关键字）但没有被使用。 2.标识符2.1.定义：就是给类，变量，接口，方法起名。2.2.组成规则：由且仅由数字（0-9），英文字母大小写，$，_，组成。 2.3.注意事项：2.3.1.只能由组成规则规定的内容组成。 2.3.2.首字母不可以为数字。 2.3.3.严重区分大小写。 2.3.4.不可以为JAVA关键字。（包括预留关键字） 2.4.常用的命名规则：见名知意，驼峰命名。2.4.1.包（文件夹，用于区分同名类）： 全部小写。如果是多级包，则单词间用.分开。 例： com 一级包 cn.itcast 二级包 注意：www.itcast.cn(一般我们是保存为域名的反写) 2.4.2.类和接口： 如果是一个单词，首字母大写：Aaa 如果是多个单词，每个单词首字母大写：AaaBbbCcc 2.4.3.变量和方法： 如果是一个单词，首字母小写：aaa 如果是多个单词，除第一个单词外，每个单词首字母大写：aaaBbbCcc 2.4.4.常量： 全部大写，如果为多个单词，在单词间加_：AAA_BBB_CCC 3.注释3.1.定义：就是对程序的解释性文字，不被JAVA识别运行。3.2.注释的分类：1.单行注释：//开头，回车结束。可嵌套。 2.多行注释：//开头，//结束。不可嵌套。 3.文档注释：//开头，//*/结束。可以被Javadoc工具解析，生成一个说明书。 3.3.注释的作用：1.解释程序的运行，提高程序代码的可阅读性。 2.可以帮助调试错误。 3.4.把HelloWorld案例用注释改版。4.常量4.1.定义：在程序的运行过程红，其值是不发生改变的量。4.2.常量的分类：1.字面值常量： 1.整数常量：12，-23 2.实数常量：12.5，-32.34 3.字符常量：’a’，’a’，’0’ 4.布尔常量：true，false 5.空常量：null 2.自定义常量 5.进制5.1.定义：是一种进位的方式。X进制，表示逢X进1。5.2.JAVA中整书常量的表示。1.二进制 由0,1组成。以0b开头。JDK7以后的新特性。 2.八进制 由0-7组成。以0开头。 3.十进制 由0-9组成。默认就是十进制。 4.十六进制 由0-9，A-F(不区分大小写)组成，以0x开头。 5.3.进制的转换：1.其他进制到十进制： 系数：就是每一位上的数据。 基数：X进制，基数就是X。 权：在右边，从0开始编号，对应位上的编号即为该位的权。 结果：把系数/*基数的权次幂相加即可。 2.十进制到其他进制：除基取余，直到商为0，余数反转。 3.快速转换： 1.8421码。 2.二进制–八进制(3位组合) 3.二进制–十六进制(4位组合) 6.变量6.1.定义：程序运行过程中，在指定范围发生改变的量。6.2.格式：数据类型： 变量名=初始化值； 变形格式： 数据类型 变量名； 变量名=初始化值； 7.数据类型7.1.分类：基本类型：4类8种 引用类型：类，接口，数组。 7.2.基本类型：整型：byte(1) short(2) int(4) long(8) 浮点型：float(4) double(8) 字符型：char(2) 布尔型：boolean(1)（至今无明确定义是多少位：认为是1个字节） 注意事项： 整数默认是int类型。long类型需要加L（l）后缀。 浮点型数默认是double类型。float类型需要加F（f）后缀。 7.3.类型转换：隐式转换：（从低精度到高精度） byte,short,char –int–long–float–double 强制转换：（可以从高精度到低精度） 格式：（数据类型）数据； 7.4.面试题byte b1 = 3; byte b2 = 4; byte b3 = b1 + b2; byte b4 = 3 + 4; 8.运算符（部分）8.1.定义：就是把常量和变量连接起来的符号，一般参与到运算中使用。8.2.分类：算术运算符；负值运算符；关系运算符；逻辑运算符；位运算符；三元运算符； 8.3.算术运算符：+,-,/*,/,%,++,–+：正号，加法，字符串连接符。 System.out.println(“5+5=”+5+5);//5+5=55 System.out.println(5+5+”=5+5”);//10=5+5 %：取得余数： 左边如果大于右边，结果是余数。左边如果小于右边，结果是左边。左边如果等于右边，结果是0。正负号跟左边一致。 ++/–：++ 其实相当于把数据+1 单独使用：在数据的前后，结果一致。 参与操作使用：如果在数据的后边，数据先操作，在++/–；如果在数据的前边，数据先++/–，在操作。 8.4.赋值运算符：=,+=,-=,/*=,/=,%=int a = 10;：把10赋值给int类型的变量a。 a += 20;：把左边和右边的和赋值给左边。 注意事项： a = a + 20; a += 20; 结果是等价的，理解不是等价的。因为+=这种运算符，内含了强制类型转换功能。比如： short s = 2; s+=3; 等价于s = (short)(s+3); ———————–android培训、java培训、java学习型技术博客、期待与您交流！ ———————- 详情请查看：http://edu.csdn.net/]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
        <tag>教程</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马程序员-JAVA概述]]></title>
    <url>%2F2013%2F12%2F02%2FJAVA%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[1.计算机基础知识1.1.计算机,硬件,软件计算机(Computer):电子计算机,电脑.计算机现已经应用渗透到社会各个领域.推动人们工作,生活,学习各种发展. 计算机硬件:(Computer Hardware）是指计算机系统中由电子,机械和光电元件等组成的各种物理装置的总称.这些物理装置按系统结构的要求构成一个有机整体为计算机软件运行提供物质基础.计算机通常由CPU、主板、内存、电源、主机箱、硬盘、显卡、键盘、鼠标,显示器等多个部件组成. 计算机软件:计算机软件是使用计算机过程中必不可少的东西，计算机软件可以使计算机按照事先预定好的顺序完成特定的功能，计算机软件按照其功能划分为系统软件与应用软件. 系统软件:DOS(Disk Operating System), Windows, Linux, Unix, Mac, Android, iOS 应用软件:office QQ聊天 YY语言 扫雷 1.2.计算机软件开发软件:按照特定顺序组织的计算机数据和指令的集合. 开发:软件的制作过程. 软件开发:借助开发工具,计算机语言制作程序,软件. 1.3.计算机语言语言:人类进行沟通交流的各种表达符号,方便人与人之间进行沟通与信息交换. 计算机语言:人与计算机之间进行的信息交流沟通的一种特殊语言.计算机语言,也有字符,符号等等.常见计算机语言:C,C++,JAVA 1.4.人机交互方式软件的出现实现了人与计算机之间的更好的交流互动. 交互方式:–图形化界面:此方式简单直观,易于使用者接受,容易上手操作. --命令行方式:需要一个特定的控制台,输入特定的指令,让季孙吉完成一些操作.较为麻烦,需要记录那些命令. 1.5.键盘功能键,快捷键介绍键盘功能键: Tab Shift Ctrl Alt 空格 Enter Window 上下左右…… PrtScr(PrintScreen)截屏 快捷键(组合): Ctrl+A 全选 Ctrl+C 复制 Ctrl+Z 撤销 Ctrl+V 粘贴 Ctrl+X 剪切 Ctrl+S 保存 1.6.常用的dos命令打开DOS控制台方式:开始菜单;运行,cmd;Win+R,cmd; 常用DOS命令: d:回车 盘符切换 dir(directory) 列出当前目录下文件以及文件夹 md(make directory) 创建目录 rd(remove directory) 删除目录 cd(change directory) 改变指定目录(进入指定目录) cd.. 退回到上一级目录 cd\ 退回到根目录 del(delete) 删除文件,删除删除一堆文件名后缀名一样的文件用/*.txt exit 退出DOS命令行 cls(clear screen) 清屏 2.JAVA语言概述JAVA语言发展史:詹姆斯.高斯林(JamesGosling) JAVA语言平台版本(JAVASE,JAVAME,JAVAEE) JAVA语言特点: 简单性,解释性,面对对象,高性能,分布式处理,多线程,健壮性,动态,结构中立,安全性,开源,跨平台. 跨平台性:通过JAVA语言编写的应用程序在不同系统平台上都可以运行. 原理:只需要在运行JAVA应用程序的操作系统上,先安装一个JAVA虚拟机(JVM).由JVM来负责JAVA程序在该系统中的运行. JRE,JDK,JVM JRE:Java runtime environment JDK:Java development kit JVM:Java virtue machine 3.JDK的下载,安装通过官网http://www.oracle.com选择对应版本,下载安装 4.HellowWorld案例4.1.开发工具介绍编写java程序可以使用很多工具 notepad(微软自带);Editplus;Eclipse;MyEclipse 4.2.HelloWorld首先定义一个类: class 类名 在类定以后加上一对大括号 {} 在大括号中间加上一个主(main)方法/函数 public static void main(String[] args){} 在主函数方法的大括号中添加一句输出语句 System.out.println(“hello world”); class Demo { public static void main(String[] args) { System.out.println("Hello World"); } } 4.3.程序解析首先编写JAVA源代码程序,扩展名.java 在命令行模式中,输入javac命令对源代码文件进行编译,生成对应的字码节文件 javac 源文件名.java 便宜完成后,如果美欧报错信息,输入java命令,对classpath字码节文件进行解释运行,执行时,不加后缀名.class java Demo 4.4.运行与工作原理 ![](http://img.blog.csdn.net/20131202000410875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbm90dG9ubXlzZWxm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 5.环境变量的配置5.1.path环境变量配置的作用程序的执行需要使用外部指令javac，但是javac指令仅仅能在JDK安装目录下的bin目录下时候，因此程序只能写入bin目录 程序开发过程中，不能将源代码写入JDK的安装目录，因此需要将源程序保存到任意位置的指定目录(英文目录)，所以需要使javac指令在任意目录下可以运行. 5.2.path环境变量配置方法:通过配置path环境变量，将javac指令所在目录也就是JDK安装目录下的bin目录配置到path变量下，即可使javac指令在任意目录下运行 win7,win8**系统**：右键点击桌面计算机→选择属性→选择高级系统设置→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path XP**系统**：右键点击桌面计算机→选择属性→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path 将jdk安装目录下的bin目录添加到最左边并添加分号. path环境变量的参照配置方式 新建一个变量,变量名为JAVA_HOME. 为JAVA_HOME添加变量值：JDK安装目录 将path环境变量中JDK目录修改 %JAVA_HOME%\bin; 注意:path环境变量具有先后顺序 5.3.classpath环境变量配置classpath环境变量配置方式:类似于path设置,可以理解为一个面对exe格式程序,;另一个面对class格式程序. 5.4.path和classpath的区别path环境变量里面记录的是可执行文件(exe),对可执行文件在当前路径去找,如果没有,则去path环境变量中配置的路径 去找 classpath环境变量里面记录的是java类的运行文件(class)所在的目录]]></content>
      <categories>
        <category>java笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>笔记</tag>
        <tag>黑马程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论坛好文觉得很有用]]></title>
    <url>%2F2013%2F10%2F29%2F%E8%AE%BA%E5%9D%9B%E9%87%8C%E7%9C%8B%E5%88%B0%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%8C%E8%A7%89%E5%BE%97%E5%BE%88%E6%9C%89%E7%94%A8%2F</url>
    <content type="text"><![CDATA[黑马19期卢同学的感言：现在已经工作一段时间了，那么我就来说说从入学到现在的一些感受吧，小学毕业，文笔有限，包含着看吧。来黑马之前我是一个超级小公司的服务器硬件维护工作人员，因为大学学的是计算机网络，毕业能干专业相关的工作在21世纪是多么光荣的事情，但是好景不长，我就发现这简直就是打着为社会做贡献的旗号等死的工作，但是想体现自己的价值所在，没有实力和脸是万万没有戏的，所以我就做了一个目前我感觉还算正确的选择。在学校就喜欢编程，但是出于经济和时间的限制，一直没有深入的学习过，还记得在2012和2013年换班儿的时候，我决定13年就花一年的时间来学习编程，通过一系列的筛选，识破了N多坑蒙拐骗教育机构之后选择了黑马，我为能有这样的慧眼感到骄傲，哈哈哈（我不是被黑马收买的）。 首先我感觉能通过这么长时间走完入学流程的同学是可交可教的，而且能要价这么高的机构教育质量也应该有保障，后来这两点都在黑马被验证了。其实我在这学的并不算好，可能掌握了有5分之2的知识吧。。。但是对一些后来的同学我极力劝你们要完整的听完课，并且好好吸收多敲代码呀！工作以后就一个感觉呀~书到用时方恨少啊~如果想找个好工作，给自己的将来做个更稳定的铺垫，那么好好学习天天Coding绝对是个不错的选择！ 找工作的时候我是很为自己担忧的，因为学太不扎实了，甚至是在得到录用之后我都想问面试官，你为谁要我呀~ 如果好好学完了4个月的课程，虽然不能算是一个有经验的开发人员，但是找工作绝对不成问题了，至少是一个有一年开发经验的程序猿了，那么如果说你能在4个月的基础上多做出点自己的项目呢？那恭喜你，你绝对是大牛了，1.2K不是梦，说到这，一定要提一嘴学习的重点，4个月时间在黑马像是被按下了快进键，以1.5倍的速度播放，所以一旦迷失了方向，结果就是GAME OVER！ 首先游戏和电视剧是一定要戒的，关于感情方面，也一定要先放一放(绝对经验)，然后就要大量的思考了，每天的课程一定要举一反三，就是变着花样儿的玩儿~把知识学的越灵活越好，其次就是算法，如果有经历的话一定要看一看，其实并没有太多的经验之谈了，唯一记住的就是把课堂上的东西都吸收掉并且熟练运用，就OK了。 关于找工作的薪资，一句话，一分价钱一分货，公司招人也是这个标准，要的越多责任越大，所以说，千万不要贪图高工资，8K左右就可以，关于1W以上的，最好能掂量掂量再做决定。 以上就是一些能想到的了，具体的还要自己体验才能感同身受，但是有一点想让看这篇文字的同学明白，从小老师父母就一直教导我们很多东西，但是很少听得进去，但现在基本上感觉他们说的都是对的，所以说前车之鉴能帮你少走很多弯路。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>黑马</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择了就别放弃]]></title>
    <url>%2F2013%2F10%2F28%2F%E9%80%89%E6%8B%A9%E4%BA%86%E5%B0%B1%E5%88%AB%E6%94%BE%E5%BC%83-%E5%8D%B3%E4%BD%BF%E9%94%99%E4%BA%86%E4%B9%9F%E4%B8%8D%E5%90%8E%E6%82%94%2F</url>
    <content type="text"><![CDATA[#选择了，便只顾风雨兼程 不知道等我老了的时候，会对现在的自己，或者这个时间段的自己什么评价。老人总说，男怕入错行，女怕嫁错郎。很直接，也很坦白。 毕业了，才总会慢慢想想大学或者以前的十几二十年自己做过些什么，选择过什么，坚持过什么。 我承认自己是个自卑的人，但很少有人觉得，只会有人说我人太好，不知道拒绝，性格太温和。而事实上，我只是用妥协的方式，让自己融入我接触的圈子。因为我怕别人嘲笑我，所以我总是在交际方面宁愿委屈自己，让别人尽量不反感我。这也影响了我的很多决定。太懦弱。的确这样。 刚走出校门，就开始怀念大学了，也许该是说想重过大学度过的很多日子，因为没有做出很多正确的选择。年轻的叛逆，让自己固执的不听从家人的建议，放弃自己的爱好，读了四年不感冒的生物工程。给自己的理由只是四年学下来学不到什么，学的只是为人处世，社交经历。当然，事实证明长辈走过的桥的确是比自己走过的路要更多。毕业工作了几个月，越发没办法让自己在一个连心底都没有一丝向往的行业做的更好。错了四年，却坚持错了四年或许更多时间。 其实，从小对新鲜事物的爱好，让自己很小就接触到了电脑。加上家庭一个颇有前瞻思想的小叔在九几年那个电脑还是稀罕物的年代，给家里带来了电脑这个新鲜品。我真的算是同辈里面，接触电脑最早的一批了吧。兴趣爱好可能就是从那时出现的吧。关于电脑的各种信息，市面上的各种电脑杂志，曾经流行了多少年的电脑光盘。看看书柜你那一沓沓的电脑报，大软，一大包的盗版光碟。我竟然也这么疯狂过，小时候的行为真的不像现在，受到太多自己给自己的枷锁，心理问题给自己的束缚。 现在，辞掉工作也有近一个月了。爸妈催促着考研去，考公务员去，搞不好就能走掉呢。其实我知道他们怕我闲出心里障碍了，我知道他们的爱。但，我真的不想再错下去。错过了大学的时光，错掉了自己的选择。虽然不后悔，但，不能一错再错。 选错了，不后悔，因为选择了，就别放弃。但是错过，就该铭记。 戒掉自己，从现在开始，选择一个新的我。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
</search>
